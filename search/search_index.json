{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<ul> <li>Doxygen documentation</li> <li>Rust crate documentation<ul> <li>bpf</li> <li>seabee</li> <li>tests</li> </ul> </li> </ul>"},{"location":"#demo","title":"Demo","text":"Terminal"},{"location":"capabilities/","title":"SeaBee Capabilities","text":"<p>This document exists as a way to track what the userspace program does   and what it still needs to do.</p>"},{"location":"capabilities/#threats-mitigated","title":"Threats mitigated","text":"<ul> <li>Block access to the userspace's eBPF maps via the <code>BPF_GET_FD_BY_ID</code> command     in the <code>security_bpf</code> LSM hook</li> <li>Block signals that would interrupt or terminate the userspace process group     via <code>security_task_kill</code></li> <li>Block unlinking of eBPF pinned programs via the <code>security_inode_unlink</code> LSM hook</li> <li>Block unmounting of <code>/sys</code> or <code>/sys/bpf</code> via the <code>security_sb_umount</code> LSM hook</li> <li>Block kernel module loading via the <code>security_kernel_read_file</code>,     <code>security_kernel_load_data</code>, and <code>security_kernel_module_request</code> LSM hooks</li> <li>Block ptrace of the userspace via the <code>security_ptrace_access_check</code> LSM hook</li> <li>Block killing a parent process of the userspace by running under systemd</li> </ul>"},{"location":"capabilities/#threats-investigated-and-dismissed","title":"Threats investigated and dismissed","text":"<ul> <li>Multiple eBPF programs on the same LSM hook cannot override a \"deny\" result</li> <li>Blocking eBPF pinned map access because the userspace's maps aren't pinned</li> <li>ptrace through <code>security_ptrace_traceme</code> is out of scope since it is only invoked by the process requesting to be traced and the SeaBee userspace is not doing that</li> <li>The <code>bpf_send_signal</code> helper can only signal the <code>current</code> task</li> <li>uprobe attaching to the userspace process is not a concern as long as <code>bpf_probe_write_user</code> is blocked</li> </ul>"},{"location":"capabilities/#threats-addressed-by-other-tools","title":"Threats addressed by other tools","text":""},{"location":"capabilities/#threats-yet-to-be-addressed","title":"Threats yet to be addressed","text":"<ul> <li>Handle safe <code>security_kernel_module_request</code> calls for kernel modules</li> <li>Manipulating the BPF pinned programs through <code>sys_bpf</code><ul> <li>open, write, read, etc.</li> </ul> </li> <li>prevention of blocking our necessary permissions</li> <li>Does mounting BPFFS in a container/namespace cause the umount protections to fail?</li> <li>Prevent removing <code>bpf</code> from the LSM kernel command-line in the GRUB config</li> </ul>"},{"location":"ci/","title":"GitLab Continuous Integration Workflow","text":"<p>Disclaimer: these notes primarily apply to GitLab. Since the project has moved to GitHub, there have been substantial changes.</p> <p>This guide explains the thoughts and considerations behind why the CI/CD   pipeline is setup the way it is.</p>"},{"location":"ci/#linting-formatting","title":"Linting &amp; Formatting","text":"<p>This is primarily provided by MegaLinter.</p> <p>Rust's <code>clippy</code> is supported by MegaLinter,   but the current project requires system dependencies in order to compile   the eBPF bytecode to embed inside the Rust code (see <code>build.rs</code>). This requires using a separate VM or container which has these dependencies.</p> <p>Rust's built-in formatter <code>cargo fmt</code> is not available in MegaLinter and is   therefore ran separately to check for style inconsistencies in <code>.rs</code> files.</p>"},{"location":"ci/#testing","title":"Testing","text":"<p>To run eBPF programs and the tests against them,   we need a sufficiently new enough kernel that has all of the features (v5.14+).</p> <p>To run a new enough kernel for a CI job (container or not),   we must provide our own VM for GitLab to run the job on.</p> <p>To run our own VM with the latest kernel,   we cannot deploy on EC2 due to the limited AMI options.</p> <p>To this end, Terraform is utilized to programmatically create   a VM on our own hardware through libvirt/QEMU and install the   GitLab Runner to accept and run jobs. Terraform by itself simply interacts with infrastructure providers to provision VMs.</p> <p>It is generally not recommended to allow GitLab CI jobs to change the state of the   underlying system that is running the GitLab Runner process. As a result,   Docker or Kubernetes is often used to run the job in a containerized environment. However, official Docker container providers (Ubuntu, Fedora, etc.) do not have the   project's system dependencies installed and have to be installed on each run. In order to not incur this overhead, a custom container image can be created. In our case, a custom Dockerfile can be used.</p>"},{"location":"ci/#docker-image","title":"Docker Image","text":"<p>The <code>ci</code> folder contains Dockerfiles which will install all of the   dependencies necessary to compile, format, and document the Rust   code.</p> <p>These images should be built manually on your development workstation   and then uploaded to your Docker registry server under the name <code>build</code>.</p> <pre><code>docker build -t build -f ci/Dockerfile .\n</code></pre> <p>NOTE - If you are using a Docker mirror for base images, you need to use the   <code>--build-arg DOCKER_MIRROR=&lt;url&gt;</code> syntax to set it with a <code>/</code> at the end</p> <pre><code>docker build -t build -f ci/Dockerfile --build-arg DOCKER_MIRROR=your.docker.mirror:1234/ .\n</code></pre>"},{"location":"ci/#gitlab-ci-variables","title":"GitLab CI Variables","text":"<p>The following variables need to be set for the full CI pipeline to work</p>"},{"location":"ci/#docker_mirror","title":"DOCKER_MIRROR","text":"<p>Optional if you are using a Docker mirror to cache images.</p>"},{"location":"ci/#edit_uri","title":"EDIT_URI","text":"<p>The URI to use for generating direct links to edit the page in the source   code repository.</p>"},{"location":"ci/#repo_name","title":"REPO_NAME","text":"<p>The name of the repository to use in the generated documentation.</p>"},{"location":"ci/#repo_url","title":"REPO_URL","text":"<p>The full URL to the source code repository.</p>"},{"location":"ci/#site_url","title":"SITE_URL","text":"<p>The full URL to the GitLab Pages or other static web server that will host   the compiled documentation.</p> <p>The default uses the GitLab scheme, but for GitHub it will need to be changed.</p>"},{"location":"ci/#running","title":"Running","text":"<p>For Terraform, the ideal place to run private VMs are on your own infrastructure.</p> <p>After logging into your server, install Terraform by following the guide:</p> <ul> <li>Terraform Installation</li> </ul> <pre><code># Check out the Terraform scripts into a new directory\ngit clone &lt;repo_url&gt;\ncd terraform\n# Create a GitLab runner for the group if necessary\ncd gitlab_runner\nterraform init\nterraform apply\n</code></pre>"},{"location":"ci/#destroying","title":"Destroying","text":"<p>In the same folder that your <code>*.tfstate</code> files were created when you ran   <code>terraform apply</code>, you can run <code>terraform destroy</code> to have all resources   Terraform created to be deleted too.</p>"},{"location":"config/","title":"SeaBee Configuration","text":"<p>This document explains how to configure SeaBee. SeaBee configuration controls how SeaBee runs and is distinct from SeaBee Policy which controls how SeaBee protects other applications.</p> <p>SeaBee configuration is mostly explained through the help menu with <code>seabee --help</code></p> <p>The SeaBee configuration cannot be updated while SeaBee is running.</p> <p>Some of the SeaBee configuration options overlap with SeaBee policy options. This is because SeaBee uses the same underlying mechanisms to protect itself and other applications.</p>"},{"location":"config/#default-configuration","title":"Default Configuration","text":"<p>The default configuration is a secure way to use SeaBee.</p> <p>Here is the default configuration in YAML format:</p> <pre><code># Info provides helpful, but not security-related information to the user\nlog_level: info\n# Block access to SeaBee created maps\nmap_access: block\n# Enable pin protection for SeaBee created pins\ninclude_pins: true\n# sigint is not allowed\nsigint: false\n# kernel module loading is only audited\nkmod: audit\n# block access to SeaBee files and policy\nfile_write_access: block\n# block ptrace\nptrace_access: block\n# nothing is excluded\n# exclude:\n# digital signature verification is enabled\nverify_policy: true\n# by default anyone can add a key to SeaBee\nverify_keys: false\n</code></pre>"},{"location":"config/#configuration-options","title":"Configuration Options","text":"<p>This section will look each configuration option with more detail.</p>"},{"location":"config/#log-level","title":"<code>log-level</code>","text":"<p>Specifies the minimum log level for SeaBee. If <code>warn</code> is specified, then only <code>warn</code> and <code>error</code> messages will be logged.</p> <p>see logging docs for descriptions of each log level.</p>"},{"location":"config/#map-access","title":"<code>map-access</code>","text":"<p>Specifies action for external access to SeaBee created eBPF maps.</p> <p>It is important for SeaBee security that this option is set to <code>block</code>.</p>"},{"location":"config/#include-pins","title":"<code>include-pins</code>","text":"<p>Specifies whether or not eBPF pins created by SeaBee are protected. If true, then they will be protected according to the value of the <code>file_write_access</code> option.</p> <p>Because SeaBee pins its program, they will remain running if Seabee crashes unexpectedly. If this occurs, the only way to recover and restart SeaBee is through a reboot.</p>"},{"location":"config/#sigint","title":"<code>sigint</code>","text":"<p>If true, allows you to kill SeaBee with signal 2 or <code>SIGINT</code> or ctrl+C. This is very useful for testing and debugging.</p> <p>Default is false to ensure that SeaBee remains running at all times.</p>"},{"location":"config/#kmod","title":"<code>kmod</code>","text":"<p>Specify security level for loading kernel modules.</p> <p>SeaBee is not designed for controlling the loading of kernel modules. Using <code>block</code> will block all kernel module loads which is likely to break functionality.</p> <p>This option is included to make sure SeaBee audits modifications to the kernel. While SeaBee considers compromised kernels outside of its threat model, it is still possible for privileged users to modify the kernel.</p> <p>There are many other mechanisms, most notably signed kernel modules, secure boot, and runtime attestation, which are better suited for controlling kernel modules.</p>"},{"location":"config/#file-write-access","title":"<code>file-write-access</code>","text":"<p>Specify action for external write access to SeaBee files including</p> <ul> <li>everything under <code>etc/seabee/</code></li> <li><code>/usr/sbin/seabee</code> and <code>usr/sbin/seabeectl</code></li> <li><code>/sys/fs/bpf/seabee/</code></li> <li>service file: <code>/etc/systemd/system/seabee.service</code></li> </ul>"},{"location":"config/#ptrace-access","title":"<code>ptrace-access</code>","text":"<p>Specify action for external ptrace on the SeaBee userspace process.</p> <p>Ptrace can be used to maliciously manipulate the SeaBee userspace process. However, it also used by debuggers such as <code>gdb</code>.</p> <p>For security, this option should be set to <code>block</code>.</p>"},{"location":"config/#exclude","title":"<code>exclude</code>","text":"<p>This options allows excluding certain types of logs altogether.</p> <p>This can be useful for debugging if you only want to see <code>map-access</code> related logs for example.</p> <p>This can also be used if certain log types are very noisy on a system. For example, <code>ptrace</code> can often be rather noisy.</p> <p>If a log type is excluded, SeaBee will still <code>block</code> that action, but there will be no record of that action in the logs.</p> <p>To maximally reduce noise on a production system, it is better put <code>log-level</code> to <code>warn</code>. This will include all security-critical events and nothing more.</p>"},{"location":"config/#verify-policy","title":"<code>verify-policy</code>","text":"<p>If true, every SeaBee policy must be signed by a key already added to SeaBee.</p> <p>If false, any policy can be added or removed without verification.</p> <p>Should always be true for security.</p>"},{"location":"config/#verify-keys","title":"<code>verify-keys</code>","text":"<p>False by default. True means every key file added to SeaBee must be signed by the root key. This effectively means the controller of the root key must authorize every other key that is used by SeaBee. This allows a system administrator to control who can use SeaBee.</p> <p>If this option is disabled, then anyone can use SeaBee and add keys. This does not inherently represent an integrity problem since a policy update must be signed with the same key used to create the policy. However, if anyone is allowed to add keys, it may open the door for availability attacks.</p> <p>This is because a file or binary cannot be tracked by two different SeaBee policies (see policy.md). This means that errors will occur if two different entities create conflicting SeaBee policies.</p> <p>Enabling this option allows control over who is creating SeaBee policies, but also adds a layer of complexity for using SeaBee since each user will have to obtain a signature from the root key.</p>"},{"location":"config/#ways-to-configure-seabee","title":"Ways to Configure SeaBee","text":""},{"location":"config/#configuration-via-the-command-line","title":"Configuration via the Command Line","text":"<p><code>seabee --help</code> explains all of the possible configuration options.</p>"},{"location":"config/#configuration-via-a-file","title":"Configuration via a File","text":"<p>At startup, SeaBee pulls configuration information from <code>/etc/seabee/config.yaml</code></p> <p>For convenience, this file can be updated while SeaBee is turned off via <code>seabeectl config</code>.</p> <p>This file can accept all of the same key-value pairs as the command line.</p>"},{"location":"config/#specifying-configuration-in-multiple-places","title":"Specifying Configuration in Multiple Places","text":"<p>Any option not specified will remain as the default.</p> <p>If the same option is specified in a file and on the command line, the command line takes precedence.</p>"},{"location":"crypto/","title":"Cryptography in SeaBee","text":"<p>This document explains how SeaBee uses cryptography in order to securely manage policy. It assumes you are running SeaBee with <code>-v</code> or <code>--verify-policy</code> option enabled. This option is enabled by default and is the only secure way to use SeaBee. This option enables signature verification on SeaBee policies, ensuring the authenticity and integrity of requests to update SeaBee policy. If this option is turned off, SeaBee provides no security guarantees, but will still verify signatures and report (but not block) on failure.</p>"},{"location":"crypto/#public-key-cryptography-for-digital-signatures","title":"Public Key Cryptography for Digital Signatures","text":"<p>SeaBee relies on public key cryptography for digital signatures. This section provides a short overview of using public key cryptography for digital signatures. Public key cryptography is a system in which there are two keys: a public key and a private key. The public key is visible to anyone and the private key must be kept secret. If Alice wants to send Bob a secret message in this system, Alice would encrypt her message using Bob's public key. Then Bob can decrypt Alice's message using his private key. Since Bob is the only one with access to his private key, only he can decrypt the message, and it remains secret.</p> <p>For digital signatures, we have a different goal. Alice doesn't need her message to be secret, but she wants to prove to Bob:</p> <ol> <li>She (Alice) authored the message (Authenticity)</li> <li>The message received is the same as the message sent (Integrity)</li> </ol> <p>First, Alice will create a unique message digest using a secure cryptographic hashing function like SHA-2 or SHA-3. Next, Alice will encrypt the message digest using her private key. Alice then sends the message and the encrypted digest to Bob. Bob is able to decrypt the message digest using Alice's public key. Then Bob can recalculate the digest for the message and verify that it matches Alice's encrypted digest.</p> <p>Notice that unlike the first scenario, in this system, the private key is used for encryption and the public key is used for decryption. Since Alice's public key is used to decrypt the message, Bob is confident that only Alice's private key could have encrypted the message. Since Alice is the only person in possession of her private key, Bob has achieved goal 1 and authenticated that the message came from Alice. Since the encrypted digest matches the actual digest, we have proven goal 2: that the message integrity was not compromised.</p> <p>This is exactly how SeaBee verifies the authenticity and integrity of SeaBee Policies. For the rest of this document, we will refer to the encrypted message digest as a \"digital signature\". The private encryption key is known as the \"signing key\", and the public decryption key will be known as the \"verification key\".</p>"},{"location":"crypto/#seabee-verification-keys","title":"SeaBee Verification Keys","text":"<p>SeaBee uses digital signatures to verify policy updates.</p> <p>In order to verify these signatures, verification keys must be added to SeaBee before policy updates can be made.</p> <p>A user must first generate a public private key pair. SeaBee currently supports RSA and ECDSA digital signatures and message digests using either SHA-2 or SHA-3. See Issue 42 for updates about support for PQC Algorithms.</p> <p></p> <p>Next, a user must add the key to SeaBee's key list. This is done using <code>seabeectl add-key</code>. You can see the help menu for any <code>seabeectl</code> command using <code>--help</code>. <code>seabeectl</code> is a client for interacting with SeaBee and is explained more fully in its documentation</p> <p>By default, SeaBee allows any (privileged) user to add a key. However, if the <code>verify-keys</code> option is specified in the SeaBee config, then all new keys must be signed by the SeaBee root key. This allows a system administrator to control who is able to use SeaBee. Even if this option is false, a system administrator is always able to use the root key to revoke another SeaBee key. This option defaults to false to make SeaBee easier to use without making it any less secure.</p> <p>The SeaBee root key will be explained more in the next section.</p> <p></p> <p>The SeaBee daemon performs signature verification on the key if the <code>verify-keys</code> option is specified.</p> <p></p> <p>Finally, the key is added to SeaBee's key list and saved to the filesystem in folder protected by SeaBee.</p> <p></p> <p>If the system is rebooted, SeaBee will re-load keys and revalidate their signatures from these folders. This ensures that a key will only need to be added once.</p>"},{"location":"crypto/#seabee-root-key","title":"SeaBee Root Key","text":"<p>SeaBee will requires an initial public verification key on startup. This verification key is known as the \"root key\" because it is used to control the administration of SeaBee.</p> <p>The SeaBee root key can also be used like any other SeaBee key to add, update, or remove policies. However, the SeaBee root key additionally has the following unique roles:</p> <ol> <li>Used to verify signatures for newly added keys if <code>verify-keys</code> is enabled</li> <li>Used to shutdown or turn off SeaBee with <code>seabeectl shutdown</code></li> <li>Can be used to revoke any SeaBee key with <code>seabeectl remove-key</code></li> </ol> <p>The SeaBee root public key is stored at <code>/etc/seabee/seabee_root_key.pem</code>. SeaBee prevents the root key from being updated while SeaBee is running. This means SeaBee must be turned off to modify the root key. This remains true even if <code>verify-keys</code> is disabled.</p> <p>Instructions for setting up the root key (requires openssl installed on the system: <code>openssl version</code> to check)</p> <ul> <li>Use <code>make gen-root-key</code> to generate an encrypted RSA key pair for SeaBee</li> <li>Use <code>make install-root-key</code> to copy the resulting public key to <code>/etc/seabee/seabee_root_key.pem</code></li> </ul>"},{"location":"crypto/#key-management","title":"Key Management","text":"<p>Key management refers to how keys are created, stored, distributed,used, and destroyed. Key management is a hard and complex problem, but it is critical for security.</p> <p>SeaBee needs trustworthy key management to provide any meaningful security. This is because SeaBee is moving trust away from privileged users and on to cryptographic keys. The compromise of those keys is a compromise of SeaBee.</p> <p>SeaBee keys should be kept secure using existing key management infrastructure. If no such infrastructure exists. Here are some basic principles for securing SeaBee keys.</p> <ul> <li>All SeaBee private keys and especially the SeaBee root private key should be encrypted</li> <li>SeaBee private keys should not be stored on the production systems where SeaBee is running. They should ideally be stored on a separate secure system or hardware security module (HSM).</li> <li>SeaBee keys should be revoked and deleted when they are no longer needed</li> <li>SeaBee shutdown requests should be deleted after they are used since an attacker would be able to re-use an already signed request that is left on a system to turn off SeaBee.</li> </ul>"},{"location":"crypto/#signed-policy-updates","title":"Signed Policy Updates","text":"<p>Now that we understand how SeaBee uses keys. We can start signing and updating SeaBee policy to secure applications. For information about how policies are structured, see policy docs. For an example of creating your own policy, see policy tutorial.</p> <p>When a policy is first added, a digital signature must also be included as a separate file. Recall that this digital signature is an encrypted digest or hash of the policy. You can generate signatures with <code>seabeectl sign</code> or a cryptographic library. You can check which algorithms are supported with <code>seabeectl alg</code>.</p> <p></p> <p>The SeaBee userspace with verify the signature before applying the policy.</p> <p></p> <p>After the policy is loaded, the kernel eBPF data structures are updated to reflect the new policy at which point the policy will be enforced. Then the policy and signature are saved to the filesystem. When the system reboots, all previously added policies will be reloaded and reverified after the previously loaded keys are reloaded and reverified.</p> <p></p> <p>Later, when a policy needs to be updated, the new version policy must include an updated signature that is generated using the same key. This ensures that only a user with access to a private signing key should be able to update the SeaBee policy.</p> <p>Additionally, the version number on the policy must be increased. This prevents accidental policy updates. It also forces policy removals to specify a version of policy to be removed, as opposed to being valid for every policy with a particular name. Versioning policies is also best practice.</p> <p>Finally, the scope cannot be changed on a policy update. Changing the policy scope requires creating a new policy.</p> <p></p> <p>Observe that a hypothetical \"User B\" who adds a \"Public Key B\" would not be able to update Policy A because policy A was originally signed by Public Key A.</p>"},{"location":"crypto/#seabeectl","title":"<code>seabeectl</code>","text":"<p>All updates will happen through the trusted binary <code>seabeectl</code>. For more information, try <code>seabeectl --help</code>, our seabeectl docs or do the tutorial.</p>"},{"location":"crypto/#generating-a-key-pair","title":"Generating a key pair","text":"<p>In production, keys should be generated on a separate system from where SeaBee is deployed.</p> <p>This tutorial uses <code>openssl</code> to generate keys. SeaBee accepts RSA or ECDSA keys and expects password protected .pem files.</p> <p>The following instructions are from the openssl wiki.</p> <p>generate an RSA private key with passphrase</p> <ul> <li><code>openssl genpkey -aes256 -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out rsa-private-key.pem</code></li> </ul> <p>generate an RSA public key</p> <ul> <li><code>openssl pkey -in rsa-private-key.pem -out rsa-public-key.pem -pubout</code></li> </ul> <p>generate an ECDSA private key with passphrase using NIST curve <code>P-256</code>. See NIST Recommendations for ECDSA curves.</p> <ul> <li><code>openssl genpkey -aes256 -algorithm EC -pkeyopt ec_paramgen_curve:P-256 -out ecdsa-private-key.pem</code></li> </ul> <p>generate an ECDSA public key</p> <ul> <li><code>openssl pkey -in ecdsa-private-key.pem -out ecdsa-public-key.pem -pubout</code></li> </ul>"},{"location":"crypto/#installing-the-seabee-root-key","title":"Installing the SeaBee Root Key","text":"<p>This step must be done before starting up SeaBee or it will generate an error.</p> <p><code>sudo cp ecdsa-public-key.pem /etc/seabee/seabee_root_key.pem</code></p>"},{"location":"crypto/#signing-a-seabee-policy","title":"Signing a SeaBee Policy","text":"<p><code>seabeectl</code> has a utility for signing SeaBee policies, but it is also possible to use <code>openssl</code>. We will use the ECDSA key from the previous section to do signing. By default, SeaBee expects the message digest to be <code>sha3-256</code>, but any <code>SHA2</code> or <code>SHA3</code> can be used by specifying it in the policy file or on the command line using <code>seabeectl sign -d</code></p> <p>Using <code>seabeectl</code></p> <ul> <li><code>sudo seabeectl sign -t test_policy.yaml -k ecdsa-private-key.pem -o signature.sign</code></li> </ul> <p>Using <code>openssl</code></p> <ul> <li><code>openssl dgst -sha3-256 -sign ecdsa-private-key.pem -out signature.sign test_policy.yaml</code></li> </ul>"},{"location":"crypto/#verifying-a-seabee-policy","title":"Verifying a SeaBee Policy","text":"<p>SeaBee will verify policies before they are loaded for the first time and whenever SeaBee receives a policy update. SeaBee will try to verify an update with each of its verification keys (recall that SeaBee is initialized with a root verification key and additional verification keys can be added). If all of SeaBee's keys fail to verify a policy update, then the update will be rejected. By default, SeaBee expects signatures to use a <code>sha3-256</code> message digest, but if the policy specifies another digest algorithm, then that algorithm will be used if SeaBee supports it.</p> <p>Using <code>openssl</code> to test verification of policy signatures</p> <ul> <li><code>openssl dgst -sha3-256 -verify ecdsa-public-key.pem -signature signature.sign test_policy.yaml</code></li> </ul> <p>Using <code>seabeectl</code> to test verification of policy signatures</p> <ul> <li><code>sudo seabeectl verify -t test_policy.yaml -k ecdsa-public-key.pem -s signature.sign</code></li> </ul>"},{"location":"folder_map/","title":"Folder Map","text":""},{"location":"folder_map/#vscode","title":"<code>.vscode</code>","text":"<p>Contains the settings necessary for VSCode extensions and their configurations.</p>"},{"location":"folder_map/#bpf","title":"<code>bpf</code>","text":"<p>This crate contains all BPF program code (<code>.bpf.c</code> and <code>.h</code>) and Rust interfaces   to interpret the data that comes from them in a ring buffer map. Utility functions useful for multiple programs should be stored under the   <code>bpf/include</code> folder as a header file. Do not write any BPF-related code other than BPF skeleton configuration outside   of this crate.</p>"},{"location":"folder_map/#ci","title":"<code>ci</code>","text":"<p>Contains the configurations necessary to compile, lint, and test the code in a ci. See its documentation for more info.</p>"},{"location":"folder_map/#docs","title":"<code>docs</code>","text":"<p>Contains a majority of the high-level documentation for the project.</p>"},{"location":"folder_map/#sample_policy","title":"<code>sample_policy</code>","text":"<p>Contains SeaBee policy examples.</p>"},{"location":"folder_map/#scripts","title":"<code>scripts</code>","text":"<p>Contains all of the shell scripts used for installation and configuring.</p>"},{"location":"folder_map/#seabee","title":"<code>seabee</code>","text":"<p>Contains all the code specific to the SeaBee program.</p>"},{"location":"folder_map/#tests","title":"<code>tests</code>","text":"<p>Contains all of the code and configurations necessary   to run integration tests against the code to ensure the capabilities   and protections offered by SeaBee actually work.</p>"},{"location":"getting_started/","title":"Getting Started with SeaBee","text":"<p>Do all of the following steps in order to make sure SeaBee is correctly installed on your system</p>"},{"location":"getting_started/#is-your-linux-supported","title":"Is Your Linux Supported?","text":"<p>See the system requirements to check if SeaBee will run in your environment.</p>"},{"location":"getting_started/#installing-seabee","title":"Installing SeaBee","text":"<p>Since SeaBee is not distributed as a binary, you will have to build it from source.</p> <p>On a new system, you may need to install <code>git</code> and <code>make</code> manually with your package manager</p> <ul> <li>Clone this repository with <code>git</code></li> <li>Change into the directory <code>cd seabee</code></li> <li>Install the dependencies with <code>make update</code><ul> <li>This should take a few minutes to run</li> </ul> </li> <li>Reload shell <code>source ~/.bashrc</code></li> </ul>"},{"location":"getting_started/#compile-seabee","title":"Compile SeaBee","text":"<ul> <li>To compile the debug version: <code>make all</code></li> <li>To compile the release version: <code>make release</code></li> </ul> <p>Troubleshooting</p> <ul> <li><code>make: cargo: No such file or directory</code><ul> <li>you forgot to <code>source ~/.bashrc</code></li> </ul> </li> <li>Build errors or missing dependencies<ul> <li>something probably went wrong in the install script. Try re-running the install script</li> </ul> </li> <li>Full Troubleshooting Docs</li> </ul> <p>If errors persist, make an issue on our GitHub.</p>"},{"location":"getting_started/#install-binaries","title":"Install binaries","text":"<ul> <li>Use <code>make install</code> to install compiled binaries to <code>/usr/sbin</code></li> </ul>"},{"location":"getting_started/#create-a-seabee-root-key","title":"Create a SeaBee Root Key","text":"<p>SeaBee requires a root key in order to run. If no root key is installed, SeaBee will fail to run. This key is used to turn off SeaBee and optionally to verify the keys used to add SeaBee policies (if <code>--verify-keys</code> is enabled)</p> <p>Read more here: Cryptography in SeaBee</p> <p>The following commands require openssl installed on the system, the best way to do that is with your package manager (<code>apt</code> or <code>dnf</code>)</p> <ul> <li>Use <code>make gen-root-key</code> to generate an encrypted RSA key pair for SeaBee<ul> <li>In production, it would be better to store the root private key on a separate secure system</li> <li>if you are only using SeaBee experimentally, use <code>make gen-root-key-ci</code> to generate an unencrypted root key</li> </ul> </li> <li>Use <code>make install-root-key</code> to copy the resulting public key to <code>/etc/seabee/seabee_root_key.pem</code></li> </ul>"},{"location":"getting_started/#run-seabee-test-cases-to-verify-functionality","title":"Run SeaBee Test Cases to Verify Functionality","text":"<p>Before running tests make you completed</p> <ul> <li>running <code>make install</code></li> <li>creating a root key</li> </ul> <p>run full test suite: <code>make test</code></p> <p>If the tests fail, see if there is an open GitHub issue regarding that error message. If not, please create one!</p>"},{"location":"getting_started/#run-seabee-in-terminal","title":"Run SeaBee in Terminal","text":"<ul> <li>make sure you've compiled: <code>make all</code></li> <li><code>sudo target/debug/seabee -s allow</code></li> <li>You should get an <code>Error reading from keylist</code> since you haven't added any keys yet!</li> </ul> <p>we highly recommend running with options during testing/experimentation to prevent needing to reboot the machine in order to stop the program. This may occur because the program is designed to be difficult to remove, even in the presence of a malicious superuser.</p> <ul> <li><code>-s allow</code> allow killing the program with ctrl+c (sigint)</li> <li><code>-p allow</code> allows removing the pinned programs from the bpf filesystem which effectively stops the program.<ul> <li>remove pins with <code>sudo rm -r /sys/fs/bpf/seabee</code></li> </ul> </li> </ul>"},{"location":"getting_started/#run-seabee-as-a-daemon","title":"Run SeaBee as a Daemon","text":"<ul> <li>To launch the daemon with release version: <code>make run</code></li> <li>To install the daemon to run on next boot: <code>make enable</code></li> <li>can currently be reversed with <code>sudo systemctl disable seabee.service</code></li> </ul> <p>To turn off Seabee, see seabeectl shutdown</p> <p>NOTE: after running the test cases, you can use the <code>test_seabee</code> daemon:</p> <ul> <li><code>sudo systemctl start test_seabee</code></li> <li><code>sudo systemctl status test_seabee</code></li> <li><code>sudo systemctl stop test_seabee</code></li> </ul>"},{"location":"getting_started/#seabee-tutorial","title":"SeaBee Tutorial","text":"<p>Great! You're all ready to go.</p> <p>We highly recommend you start with the SeaBee tutorial if you are unfamiliar with SeaBee.</p>"},{"location":"implementation/","title":"Implementation Notes","text":""},{"location":"implementation/#bpf-naming-conventions","title":"BPF Naming Conventions","text":"<p>The BPF-to-Rust-skeleton compilation uses the name of the <code>.bpf.c</code> file     as the module name and prefixes for module functions. <code>my_bpf_program.bpf.c</code> will be converted into <code>mod MyBpfProgram;</code>   and <code>MyBpfProgramSkelBuilder</code> and other <code>MyBpfProgram...</code> prefixes.</p>"},{"location":"implementation/#adding-new-hooks","title":"Adding new hooks","text":"<p>When adding new LSM hooks, you have to be careful because the semantics of LSM hooks can change between kernel versions. Although changes are uncommon, they do happen. Make sure the test your code on all kernel versions when adding new hooks.</p> <p>If a hook changes between kernel versions, then you need to define two versions of the hook and determine which one to use at compile time. While there are some advantages to compiling multiple versions and choosing the correct version at runtime. This approach ran into other difficulties. This means that currently SeaBee must be compiled for the specific kernel version it is going to run on. For more information on this decision, see issue #9</p>"},{"location":"implementation/#logging","title":"Logging","text":"<p>So you've written up a new BPF program, that's great! Unfortunately, you've been using <code>bpf_printk</code> in your code. While this is nice for quick testing of your prototype,   it isn't a great long term solution. We want to have custom logs for your BPF program in a designated location. However, setting that up takes a couple steps. Don't worry though, it'll look great when we're done!</p>"},{"location":"implementation/#logging-a-new-bpf-hook","title":"Logging A New BPF Hook","text":"<ol> <li>Add a new entry to the <code>log_type</code> enum in <code>bpf/include/logging_types.h</code>.    This allows translation between the C log structs and the generated Rust log structs.</li> <li>Add a new struct in <code>bpf/include/logging_types.h</code> with the      name <code>*_log</code> where <code>*</code> is the name of the BPF program.    This struct describes any contextual info relevant to the hook.    At a minimum, it should contain the info used to make the access control decision.</li> <li>Create a logging function in <code>bpf/src/seabee_enforce/self_enforce_log.h</code>.    Follow the pattern of the other functions already present.    Instantiate the struct from step 2 and send it to the ring buffer.    Use the <code>log_type</code> defined in the first step to aid the C-to-Rust translation.</li> <li>Replace <code>bpf_printk</code> calls with the new log function.    Choose a <code>reason</code> and a <code>level</code> for each call.    The <code>reason</code> explains why the log is being printed.    For example, <code>LOG_REASON_DENY</code>, suggests that some action was attempted and denied.    The <code>level</code> defines a relative level of importance of the log.    This allows some customization of how many logs are printed.    Typically only the most critical logs will be printed,      but if a problem is being debugged, including less important logs may be helpful.    In order to differentiate between different reasons and levels,      code may need to be restructured.</li> <li>Add the struct to the <code>get_log_struct</code> function in <code>bpf/src/logging/mod.rs</code>.    Following the pattern of other logs,      add a case to the match statement and include the new <code>log_type</code> enum value and log struct.    The <code>ToString</code> trait must also be implemented to print the log.    Follow the pattern of other structs in the file.    Note: The name of the struct and <code>log_type</code> need to match in Rust and C,       otherwise it will fail to compile.</li> </ol>"},{"location":"implementation/#logging-for-a-new-ebpf-skeleton","title":"Logging for a new eBPF Skeleton","text":"<p>Note: SeaBee no longer uses multiple skeletons</p> <ul> <li>Setup logging in skeleton code (c code)<ul> <li><code>#include \"logging.h\"</code></li> <li>create a global variable for log level: <code>u32 log_level;</code></li> <li>add the ringbuf: <code>struct log_ringbuf log_ringbuf SEC(\".maps\");</code></li> </ul> </li> <li>Setup the userspace code<ul> <li>configure skeleton log level: <code>open_skel.bss_mut().log_level = ...</code>;</li> <li>configure skeleton ringbuf: <code>open_skel.maps().log_ringbuf().reuse_fd(&lt;original log ringbuf&gt;.as_fd())?;</code></li> </ul> </li> </ul>"},{"location":"logging/","title":"Logging","text":""},{"location":"logging/#viewing-logs","title":"Viewing Logs","text":"<p>When running SeaBee on the command line, logs will be printed to standard output.</p> <p>When running SeaBee under systemd, logs will be printed to the journal.</p> <ul> <li>test logs: <code>sudo journalctl -u test_seabee -f</code></li> <li>non-test logs: <code>sudo journalctl -u seabee -f</code></li> </ul>"},{"location":"logging/#log-levels","title":"Log Levels","text":"<p>to configure the log level, see config docs</p> <ul> <li>Log Level Error: Indicates something unexpected, a problem or bug in the code</li> <li>Log Level Warn: Most commonly used when SeaBee blocks an action, correlates with security level 'blocked' in policy</li> <li>Log Level Info: Prints useful, but not security-related information to the user. Also correlates with security level 'audit' in policy.</li> <li>Log Level Debug: Primarily identifies control flow to help debug where an error happens.</li> <li>Log Level Trace: Similar to debug, but even more fine-grained. Includes labeling and kernel tracing information.</li> </ul>"},{"location":"policy/","title":"SeaBee Policy","text":"<p>This document is intended to provide an overview and in-depth explanations of how SeaBee policies work.</p>"},{"location":"policy/#policy-overview","title":"Policy Overview","text":"<ul> <li>SeaBee provides isolation for eBPF applications via policy</li> <li>Policy is defined for an executable or a set of executables (the policy scope)</li> <li>SeaBee detects when protected objects (e.g. eBPF maps) are created by a process in the policy scope and assigns them with the corresponding policy ID including the process itself</li> <li>Any executable or process will have access to all protected objects with the same Policy ID as itself, which indicates that it falls within the same scope.</li> <li>A SeaBee policy for an executable must be loaded before that executable starts in order for SeaBee to associate the path of the executable with the created process and protect eBPF objects for that process. When run as a systemd daemon(strongly recommended), SeaBee must start before other daemon applications during boot in order to protect them. If an application using SeaBee starts early during boot, it must ensure that it starts after SeaBee (or add SeaBee as a dependency).</li> </ul>"},{"location":"policy/#definitions","title":"Definitions","text":"<ul> <li>Protected Object: anything that SeaBee protects including: processes, eBPF maps, pinned programs, files, and directories.</li> <li>Policy ID: Each policy is assigned a Policy ID. The Policy ID is used to identify protected objects associated with the same policy. All objects in the same policy have the same Policy ID.</li> <li>Action: SeaBee supports three actions: allow, audit, and block. Actions are defined in the policy config. Actions determine how external processes can interact with protected objects under a policy. The action can be different for each protected object. For example: \"map_access: audit\" would audit, but allow any external process to access a map that is within the policy scope.</li> </ul>"},{"location":"policy/#sample-policy","title":"Sample Policy","text":"<p>Here is a sample annotated SeaBee policy. The rest of this document will walk through each part of the policy. At the end, there is a discussion of the limitations of SeaBee policies.</p> <p>More example policies can be seen at <code>tests/policies</code></p> <pre><code># names must be unique\nname: sample-policy\n# version should be incremented on policy update\nversion: 1\nscope:\n  # this executable and all processes it creates are in scope\n  - /usr/sbin/my-ebpf-tool\nfiles:\n  # all files created in this folder will be protected according to the \"file_write_access\" rule\n  - /etc/my-ebpf-tool/\nconfig:\n  # block external access to maps created by a process in scope\n  map_access: block\n  # block external access to files listed in \"files:\"\n  file_write_access: block\n  # block access to eBPF pins in addition to \"files:\"\n  include_pins: true\n  # audit, but allow signals not specified in allow_mask\n  signals: audit\n  # since no signals are specified, all signals will be audited or blocked\n  signal_allow_mask: 0x0\n  # any options not included in config will be left to a secure default, usually blocking\n</code></pre>"},{"location":"policy/#policy-anatomy","title":"Policy Anatomy","text":"<p>This section gives a more detailed overview of each part of a policy.</p>"},{"location":"policy/#name","title":"Name","text":"<p>The name of the policy is used to uniquely identify a policy. If you try to add a policy with the same name as an existing policy, SeaBee will interpret it as an attempt to update the existing policy. This will mostly likely result in an error, or overwriting the old policy if your new policy uses the same key and a higher version number.</p>"},{"location":"policy/#version","title":"Version","text":"<p>The version should be incremented when a policy is updated. The version ensures that an attacker cannot downgrade the policy to an old version or maliciously update a policy.</p>"},{"location":"policy/#scope","title":"Scope","text":"<p>A list of paths to executables. These paths are used to determine what is protected by a SeaBee policy. All child process will be in scope. All eBPF maps or pins are in scope as well. Files created in a protected directory are in scope as well as files or directories specified in the policy.</p> <p>If paths are scopes are symbolic links to binaries, it will not work correctly. Seabee will not follow symbolic links. This is an open issue and can be see at Issue 12.</p> <p>SeaBee implements a scope by storing the policy ID for each protected object. Currently each object can only have one policy ID assigned to it. This limits policy flexibility since two different policies cannot have overlapping scopes. This is being addressed in issue 34. Assigning a policy ID to an object is sometimes referred to as \"Labeling\". The following diagram shows the basic runtime labeling rules for SeaBee.</p> <p></p>"},{"location":"policy/#files","title":"Files","text":"<p>This section determines which files are protected by the policy. It may be the case that there are repeated files between <code>scope</code> and <code>files</code>. This would be the case if you wanted to prevent an executable from being modified and have that executable and its children in scope.</p> <p>The paths listed in this section can include directories, files, and some other types of linux directory entries. For each entry SeaBee will attempt to label the underlying inode. These labels are used to enforce security controls. If the entry is a directory, SeaBee uses the <code>walkdir</code> crate to recursively iterate through all subdirectories and label everything in those directories as well. This directory walk will not follow symlinks.</p> <p>All of paths you specify must exist when the policy is loaded. If one of your files does not exist on policy load, then SeaBee will generate an error. In order to protect files that are created at runtime, the current approach is to specify a directory and all files/directories created in that directory at runtime will be protected. If support for protecting files at runtime is important to you, leave a comment on our GitHub letting us know: Issue 35.</p>"},{"location":"policy/#config","title":"Config","text":"<p>The policy config determines what protections this policy provides to processes and objects created within the <code>scope</code>. If an option is not specified in the policy it will default to block, unless otherwise specified.</p> <p>config has the following keys:</p> <ul> <li><code>map_access</code>: control access to eBPF maps within the scope (allow, audit, block)</li> <li><code>file_write_access</code>: control write access to the files listed in <code>files</code> section (allow, audit, block)</li> <li><code>include_pins</code>: should eBPF pins be protected in addition to <code>files</code>? If true, all eBPF pins created within scope will be protected according to the <code>file_write_access</code> level (true, false)</li> <li><code>ptrace_access</code>: control if ptrace can be used on processes in scope (allow, audit, block)</li> <li><code>signal_access</code>: control how to enforce the sigmask (allow, audit, block)</li> <li><code>signal_allow_mask</code>: determines which signals should be allowed (see below)<ul> <li>default is <code>0x8430000</code> (see below for details)</li> </ul> </li> </ul>"},{"location":"policy/#sigmask","title":"Sigmask","text":"<p>The sigmask requires further explanation. The sigmask allows a user to precisely control which signals are allowed to be sent to a process within scope. To construct a sigmask, you need to first enumerate the codes for each signal you want to allow. For example, if you want to allow SIGINT, you should get code 2.</p> <p>The sigmask is a <code>u64</code> so it covers all possible signals including RT signals 32 through 64. The null signal is not part of the standard signal set and therefore cannot be blocked We construct the sigmask by taking the code for each signal we want to block, subtracting 1, and flipping that bit to a 1 <code>(1&lt;&lt;(CODE-1))</code>. For SIGINT, we do <code>(1&lt;&lt;(2-1))</code> and get <code>0x2</code>.</p> <p>The <code>0x2</code> sigmask will allow SIGINT but block all other signals to the process (if <code>signals</code> is set to <code>block</code>)</p> <p>Setting <code>signals: allow</code> will cause the sigmask to be ignored altogether.</p> <p>Sigmask can be specified as a hex or a decimal in the policy</p> <p>We use this sigmask by default for SeaBee: <code>0x8430000</code>. This allows all signals that don't kill the process by default. We generate the sigmask with the following code (from <code>seabee/src/utils.rs</code>)</p> <pre><code>/// Generates a [mask](https://en.wikipedia.org/wiki/Mask_(computing))\n/// of allowed signals\npub const fn generate_sigmask(sigint: SecurityLevel) -&gt; u64 {\n    let mut sigmask: u64 = 0;\n    // These signals are those that do not terminate a process by default\n    sigmask |= 1 &lt;&lt; (Signal::SIGCHLD as u64 - 1);\n    sigmask |= 1 &lt;&lt; (Signal::SIGCONT as u64 - 1);\n    sigmask |= 1 &lt;&lt; (Signal::SIGURG as u64 - 1);\n    sigmask |= 1 &lt;&lt; (Signal::SIGWINCH as u64 - 1);\n\n    if is_sigint_allowed(sigint) {\n        sigmask |= 1 &lt;&lt; (Signal::SIGINT as u64 - 1);\n    }\n    sigmask\n}\n</code></pre>"},{"location":"policy/#policy-flexibility-and-limitations","title":"Policy Flexibility and Limitations","text":"<p>Think of a SeaBee policy as a list of \"deny\" or \"audit\" rules. By default, everything is allowed (this is the 'policy' if SeaBee is not being used). When an executable is listed under the \"scope\" for a SeaBee policy, it is allowed access to all protected object it creates. The Policy Config determines how other processes, not in policy scope, are allowed to access protected objects within a policy scope.</p> <p>Here is an example of a process trying to access and eBPF Map with SeaBee enabled.</p> <p></p> <p>When answering \"Is some process allowed to access some object?\", SeaBee considers two things:</p> <ol> <li>Does the process have the same Policy ID (scope) as the object?</li> <li>If not, does the policy config for the object's policy have an 'audit' or 'allow' action? Since these actions grant access to an external process.</li> </ol> <p>Actions in the Policy Config are only granular to the class of protected object not to each particular object. This means that you cannot have one map that is 'audit' and a different map that is 'block' for the same policy scope/executable.</p> <p>Currently, an executable or a file can only have one SeaBee policy ID. This limits what types of policies can be created since you cannot have a shared tool defined in multiple policy scopes. This may be addressed in the future through issue 34.</p>"},{"location":"policy_tutorial/","title":"Policy Tutorial","text":"<p>This is a guide for getting hands-on with SeaBee policy.</p> <p>Section 3 assumes you have already gone through</p> <ul> <li>Getting started with SeaBee</li> <li>SeaBee Tutorial</li> </ul> <p>If you're looking for documentation about the SeaBee policy, see Policy Documentation. This documentation will also be a helpful reference throughout this tutorial.</p>"},{"location":"policy_tutorial/#sample-target-application-kubearmor","title":"Sample Target Application: KubeArmor","text":"<p>KubeArmor is an open source eBPF security tool designed to protected Kubernetes workloads with security policies. We've chosen to use this tool to demonstrate the process of developing a new SeaBee policy.</p> <p>KubeArmor is a good candidate for this analysis because:</p> <ul> <li>It is open source, so our analysis can be replicated</li> <li>It has a healthy contributor community and many users that could benefit from a SeaBee policy</li> <li>Like SeaBee, it leverages the eBPF LSM for security enforcement</li> </ul> <p>This is purely instructional and should not be construed as an endorsement of KubeArmor by the US Government, the Department of War, or the NSA.</p>"},{"location":"policy_tutorial/#1-environment-for-running-kubearmor","title":"1. Environment for Running KubeArmor","text":"<p>Tested using ubuntu 24.04 (noble) with bpf lsm enabled.</p> <p>Followed KubeArmor's instructions for vm deployment to avoid the extra complexity from setting up k8s.</p> <p>This tutorial was written with version KubeArmor 1.6.3, but you may want to use a more recent version.</p> <p>Warning: we are about to download, install, and run binaries as root. If you don't trust the authors of KubeArmor, it is highly recommended to run these commands in a virtual machine or isolated environment.</p> <ul> <li><code>wget https://github.com/kubearmor/KubeArmor/releases/download/v1.6.3/kubearmor_1.6.3_linux-amd64.deb</code></li> <li><code>sudo apt --no-install-recommends install ./kubearmor_1.6.3_linux-amd64.deb</code></li> <li><code>systemctl start kubearmor</code></li> <li><code>systemctl status kubearmor</code></li> </ul> <p></p> <p>Now we need to install the <code>karmor</code> client using these instructions</p> <ul> <li>install karmor client to <code>./bin/karmor</code>: <code>curl -sfL http://get.kubearmor.io/ | sh -s</code></li> <li>check that <code>Active LSM:</code> is <code>BPFLSM</code> with <code>sudo ./bin/karmor probe</code><ul> <li>BPF LSM is KubeArmor's default choice, if the enforcer is not BPF LSM, it is likely the OS does not support it. If you are running a modern Ubuntu, then BPF LSM is supported, but must be enabled. See requirements</li> </ul> </li> </ul> <p></p> <p>Now that KubeArmor is running, and the karmor client is installed, we will add a policy:  <code>vim hostpolicy.yaml</code></p> <pre><code>apiVersion: security.kubearmor.com/v1\nkind: KubeArmorHostPolicy\nmetadata:\n  name: hsp-kubearmor-dev-proc-path-block\nspec:\n  nodeSelector:\n    matchLabels:\n      kubearmor.io/hostname: \"*\" # Apply to all hosts\n  process:\n    matchPaths:\n    - path: /usr/bin/sleep # try sleep 1\n  action:\n    Block\n</code></pre> <ul> <li>add the policy:  <code>./bin/karmor vm policy add hostpolicy.yaml</code></li> <li>test the policy with <code>sleep: 10</code><ul> <li>If you are not blocked, then reload your shell and try again</li> </ul> </li> <li>view the logs: <code>./bin/karmor logs --gRPC=:32767</code></li> </ul> <p></p> <p>Great! This permission denied indicates that KubeArmor is working, lets demonstrate how SeaBee can improve the security.</p>"},{"location":"policy_tutorial/#2-demonstrate-the-value-of-seabee","title":"2. Demonstrate The Value of SeaBee","text":""},{"location":"policy_tutorial/#goals","title":"Goals","text":"<p>KubeArmor, and most eBPF tools, do not consider privileged users in their threat model. The goal of SeaBee is to elevate the threat model of a tool to protect it from privileged users. Privileged users can trivially defeat any protections put in place with eBPF LSM. Let's see how that works with KubeArmor.</p> <p>The goal of this exercise is to remove the KubeArmor policy we created without revealing to the KubeArmor administrator that the policy has been removed. This would enable a privileged attacker to undertake any action they want without being blocked or monitored by the security software on the system, in this case: KubeArmor. At the same time, from the perspective the KubeArmor userspace and system administrator, nothing will appear unusual.</p> <p>The first step to accomplishing this is to understand how KubeArmor works.</p> <ul> <li>KubeArmor is using the eBPF LSM to enforce its security controls.</li> <li>In eBPF, all data is stored in eBPF maps. eBPF maps are just key-value stores.</li> <li>Some data from our policy must be stored in an eBPF map in order for KubeArmor to act on it (i.e. block 'sleep')</li> <li>Any privileged user can modify any eBPF map.</li> </ul> <p>So this leaves us with several objectives</p> <ol> <li>Which maps does KubeArmor use to store policy data for our policy?</li> <li>How can we overwrite the data in that map?</li> </ol>"},{"location":"policy_tutorial/#understanding-kubearmor","title":"Understanding KubeArmor","text":"<p>The best way to answer question 1. is to go into the KubeArmor source code and work backwards. Lets start by looking the at the log from when KubeArmor denied our use of 'sleep'.</p> <p></p> <p>This log has several useful pieces of information</p> <ul> <li><code>\"ProcessName\":\"/usr/bin/sleep\"</code> shows this is the correct log</li> <li><code>\"Action\":\"Block\"</code> indicates that we were blocked</li> <li><code>\"Enforcer\":\"BPFLSM\"</code> shows that BPF LSM was used</li> <li><code>lsm=SECURITY_BPRM_CHECK</code> indicates that the <code>security_bprm_check</code> LSM hook is being used to block this execution</li> </ul> <p>Taking this information, we now go to the KubeArmor source code in search of the <code>security_bprm_check</code> enforcer code.</p> <p>After a bit of intuitive searching, (alternatively use a fast search tool like <code>ripgrep</code>) we find the code at KubeArmor/BPF/enforcer.bpf.c</p> <p>It's possible this code may have moved after this demo was written in October 2025. The relevant code looks like this:</p> <pre><code>/* SPDX-License-Identifier: GPL-2.0    */\n/* Copyright 2023 Authors of KubeArmor */\nSEC(\"lsm/bprm_check_security\")\nint BPF_PROG(enforce_proc, struct linux_binprm *bprm, int ret) {\n  struct task_struct *t = (struct task_struct *)bpf_get_current_task();\n  event *task_info;\n  int retval = ret;\n\n  bool match = false;\n\n  struct outer_key okey;\n  get_outer_key(&amp;okey, t);\n\n  u32 *inner = bpf_map_lookup_elem(&amp;kubearmor_containers, &amp;okey);\n// many more lines excluded\n}\n</code></pre> <p>This shows that one of the first actions taken by this security hook is performing a lookup in an eBPF map called <code>kubearmor_containers</code>. We can find the definition for this map in a different file shared.h.</p> <p>Tip: you can navigate the codebase for KubeArmor and other tools much more quickly by cloning them from github locally and using navigation tools build in to modern IDEs such as VSCode C++ extensions. Generative AI can also be useful for searching a codebase.</p> <pre><code>/* SPDX-License-Identifier: GPL-2.0 */\n/* Copyright 2023 Authors of KubeArmor */\nstruct outer_hash {\n  __uint(type, BPF_MAP_TYPE_HASH_OF_MAPS);\n  __uint(max_entries, 256);\n  __uint(key_size, sizeof(struct outer_key));\n  __uint(value_size, sizeof(u32));\n  __uint(pinning, LIBBPF_PIN_BY_NAME);\n};\n\nstruct outer_hash kubearmor_containers SEC(\".maps\");\n</code></pre> <p>This map has type <code>BPF_MAP_TYPE_HASH_OF_MAPS</code>. Every eBPF map functions as a key-value store. This map type means that the values are also eBPF Maps.</p> <p>After exploring the code a little longer, several things become evident:</p> <ul> <li>the \"outer key\" used to access the <code>kubearmor_containers</code> map is derived from the current task (process)</li> <li>the <code>inner</code> value obtained from <code>kubearmor_containers</code> is used many times throughout the enforcement logic</li> </ul> <p>We conclude that the <code>inner</code> value must store unique data for a process that helps to determine what enforcement action should be taken. This is probably the data we want to overwrite.</p>"},{"location":"policy_tutorial/#overwriting-kubearmor-maps","title":"Overwriting KubeArmor Maps","text":"<p>In order to write data to an eBPF map, we will use <code>bpftool</code>.</p> <p>This can easily be installed with <code>apt</code> or <code>dnf</code> or built from source</p> <ul> <li><code>sudo apt install linux-tools-common linux-tools-generic linux-tools-$(uname -r)</code></li> <li><code>bpftool -V</code></li> </ul> <p>Using <code>bpftool</code> we can view all the maps on the system: <code>bpftool map list</code></p> <p>Here we can see the name and numeric id for each eBPF map. We are looking for the <code>kubearmor_containers</code> map. Since eBPF maps have a limited name length, it appears are <code>kubearmor_conta</code>.</p> <p></p> <p>In order to view the map, we use <code>sudo bpftool map dump name kubearmor_conta</code></p> <p></p> <p>This shows us that there is one entry, which we know is another eBPF map with id 606.</p> <p>We can now dump the contents of this \"inner\" map with <code>bpftool</code> as well.</p> <p></p> <p>It looks like a long array with some bytes at the beginning. If we takes those bytes and interpret them as ascii characters...</p> <p><code>2f 75 73 72 2f 62 69 6e 2f 73 6c 65 65 70</code> translates to <code>/usr/bin/sleep</code>.</p> <p>Which is the path specified in our policy! This confirms that we have located the correct data.</p> <p>Now we can just delete this data from the map with <code>bpftool</code></p> <p></p> <p>Uh oh, it looks like we are going to need a lot more zeros.</p> <p></p> <p>Now that we removed that string from the map, the security to block <code>sleep</code> is no longer enforced.</p> <p>Finally, from the perspective of the KubeArmor administrator, we observe that KubeArmor is still running and our policy is still loaded. While it seems there is somewhat limited support for viewing loaded policies in the vm mode, we can see our policy is still loaded with <code>./bin/karmor probe</code>.</p> <p></p>"},{"location":"policy_tutorial/#so-what","title":"So What?","text":"<p>This demonstrates that any privileged user can make unauthorized, anonymous, and mostly invisible policy updates to system security policy with a single command.</p> <p>Why be concerned about privileged users?</p> <ul> <li>It's not just privileged users, the same technique could be accomplished by any privileged process or daemon, or a container with privileges to use eBPF</li> <li>Insider threat may be a concern, even the actions of privileged users should be audited, especially when those actions are security-relevant</li> </ul> <p>Is this a problem with other LSMs like AppArmor and SELinux?</p> <ul> <li>No</li> <li>Privileged users can modify the policy for AppArmor and SELinux, but they don't have arbitrary access to the internal data structures used by these tools</li> <li><code>CAP_MAC_ADMIN</code> is needed to modify policy which is used less widely than <code>CAP_BPF</code></li> <li>Updates to policy are always logged</li> </ul> <p>What about tools besides KubeArmor?</p> <ul> <li>These problems are fundamental to eBPF and therefore affect almost every eBPF tool</li> <li>These same techniques can likely be used to disable security logging or network security policy in other tools</li> </ul> <p>SeaBee exists to prevent any privileged user, process, daemon, or container from modifying or disabling security critical eBPF tools like KubeArmor.</p>"},{"location":"policy_tutorial/#3-developing-seabee-policy-for-kubearmor","title":"3. Developing SeaBee Policy for KubeArmor","text":""},{"location":"policy_tutorial/#restoring-kubearmor-state","title":"Restoring KubeArmor State","text":"<p>In order to restore our KubeArmor policy so that is is enforcing again, we will remove and re-add it:</p> <ul> <li><code>sudo ./bin/karmor vm policy delete hostpolicy.yaml</code></li> <li><code>sudo ./bin/karmor vm policy add hostpolicy.yaml</code></li> <li>verify policy added with <code>sudo ./bin/karmor probe</code></li> <li><code>sleep 1</code> should return permission denied again</li> </ul>"},{"location":"policy_tutorial/#creating-a-naive-seabee-policy","title":"Creating a naive SeaBee Policy","text":"<p>First we need to find the <code>kubearmor</code> binary we want to protect. This is probably specified in the service file. We can view the path of the service file by running <code>systemctl status kubearmor</code>. For me, the service file is <code>/usr/lib/systemd/system/kubearmor.service</code></p> <pre><code>[Unit]\nDescription=KubeArmor\n\n[Service]\nUser=root\nKillMode=process\nWorkingDirectory=/opt/kubearmor/\nExecStart=/opt/kubearmor/kubearmor\nRestart=always\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>The \"ExecStart\" tells us the KubeArmor binary is installed at <code>/opt/kubearmor/kubearmor</code></p> <p>Create the following simple SeaBee policy: <code>vim kubearmor-simple-seabee-policy.yaml</code></p> <pre><code>name: kubearmor-simple-seabee-policy\nversion: 1\nscope:\n  - /opt/kubearmor/kubearmor\nfiles:\nconfig: # leave as default\n</code></pre> <ul> <li>Sign the policy: <code>sudo seabeectl sign -t kubearmor-simple-seabee-policy.yaml -k rsa-private-key.pem</code></li> <li>Start up SeaBee: <code>systemctl start test_seabee</code></li> <li>Add the policy: <code>sudo seabeectl update -t kubearmor-simple-seabee-policy.yaml -s signature.sign</code></li> </ul> <p>Note: if this isn't working, you may need to create a key pair and add a public verification key to SeaBee. You can see how to do this in the SeaBee tutorial</p> <p>Finally restart KubeArmor so the policy get applied: <code>systemctl restart kubearmor</code></p> <p>Lastly, test to see if we can manipulate KubeArmor's maps:</p> <ul> <li><code>sudo bpftool map dump name kubearmor_conta</code></li> </ul> <p></p> <p>We see that we have been denied. Among many protections, SeaBee tracks all eBPF maps created by a protected process and prevents external access to them. Thus, SeaBee prevents the attack we previously demonstrated. No more arbitrary access to the internal data structures of KubeArmor.</p>"},{"location":"policy_tutorial/#4-tailoring-a-seabee-policy-for-a-tool","title":"4. Tailoring a SeaBee Policy for a Tool","text":"<p>For this final part of the tutorial, we will take an in-depth look at each component of SeaBee policy in order to construct a policy that is more tailored for KubeArmor. By extension, this analysis should give helpful considerations when crafting policy for any other tools with SeaBee.</p> <p>If you haven't yet, reading the policy documentation will be very helpful. We are going to walk through each part of a SeaBee policy and discuss how to tailor that part of a policy for a tool.</p> <p>We will start from our simple SeaBee policy for KubeArmor and expand it step by step. Unfortunately, this process is very manual and is best completed by a developer for the tool who understands how the tool works best. Developing the policy for KubeArmor took hours of experimentation and reading documentation. The final result may still be imperfect.</p> <p>It is important to note that the SeaBee policy we create for KubeArmor will only be relevant for the vm or host mode of KubeArmor. When deploying KubeArmor on K8s as a DaemonSet, there are different artifacts to protect, more complexity and a different attack surface.</p> <pre><code>name: kubearmor-simple-seabee-policy\nversion: 1\nscope:\n  - /opt/kubearmor/kubearmor\nfiles:\nconfig: # leave as default\n</code></pre>"},{"location":"policy_tutorial/#config-signal_access-and-signal_allow_mask","title":"Config: signal_access and signal_allow_mask","text":"<p>Read about signal access in SeaBee</p> <p>We're going to start with signals because it will make it simpler to test the other parts of the policy. One of the current issues with out policy is that we block signals to <code>kubearmor</code>. As a result, some functionality is broken, like <code>systemctl stop kubearmor</code> which sends a SIGTERM(15) to the process.</p> <p>You can see this by trying <code>systemctl stop kubearmor</code> while SeaBee is running with out policy loaded.</p> <p>SeaBee logs: <code>journalctl -u test_seabee -f</code>:</p> <pre><code>Oct 23 17:58:41 ubuntu seabee[2785283]:  WARN SeaBee policy 2: task_kill: deny systemd(1) send SIGTERM(15) to kubearmor(2785562)\nOct 23 17:58:41 ubuntu seabee[2785283]:  WARN SeaBee policy 2: task_kill: deny systemd(1) send SIGKILL(9) to kubearmor(2785562)\nOct 23 17:58:41 ubuntu seabee[2785283]:  WARN SeaBee policy 2: task_kill: deny systemd(1) send SIGTERM(15) to kubearmor(2785562)\nOct 23 17:58:41 ubuntu seabee[2785283]:  WARN SeaBee policy 2: task_kill: deny systemd(1) send SIGKILL(9) to kubearmor(2785562)\n</code></pre> <p>systemd logs: <code>journalctl -u kubearmor -f</code>:</p> <pre><code>Oct 23 17:58:41 ubuntu systemd[1]: kubearmor.service: Failed to kill main process 2785562 (kubearmor), ignoring: Operation not permitted\nOct 23 17:58:41 ubuntu systemd[1]: kubearmor.service: Killing process 2785562 (kubearmor) with signal SIGKILL.\nOct 23 17:58:41 ubuntu systemd[1]: kubearmor.service: Failed to kill main process 2785562 (kubearmor), ignoring: Operation not permitted\nOct 23 17:58:41 ubuntu systemd[1]: kubearmor.service: Failed to kill main process 2785562 (kubearmor), ignoring: Operation not permitted\nOct 23 17:58:41 ubuntu systemd[1]: kubearmor.service: Killing process 2785562 (kubearmor) with signal SIGKILL.\nOct 23 17:58:41 ubuntu systemd[1]: kubearmor.service: Failed to kill main process 2785562 (kubearmor), ignoring: Operation not permitted\nOct 23 17:58:41 ubuntu systemd[1]: kubearmor.service: Deactivated successfully.\nOct 23 17:58:41 ubuntu systemd[1]: kubearmor.service: Unit process 2785562 (kubearmor) remains running after unit stopped.\n</code></pre> <p>To prevent unexpected denials like this, lets audit signals to <code>kubearmor</code> rather than block. While this allows using signals to kill KubeArmor, such actions will appear in SeaBee logs and also be shown on the process list (that <code>kubearmor</code> is no longer running)</p> <pre><code>name: kubearmor-simple-seabee-policy\nversion: 2\nscope:\n  - /opt/kubearmor/kubearmor\nfiles:\nconfig:\n  signal_access: audit\n  signal_allow_mask: 0\n</code></pre> <ul> <li>modify: <code>vim kubearmor-simple-seabee-policy.yaml</code></li> <li>sign: <code>sudo seabeectl sign -t kubearmor-simple-seabee-policy.yaml -k rsa-private-key.pem</code></li> <li>update: <code>sudo seabeectl update -t kubearmor-simple-seabee-policy.yaml -s signature.sign</code></li> </ul> <p>If you ran <code>systemctl stop kubearmor</code> while SeaBee was running, then you will have to</p> <ul> <li>stop SeaBee: <code>systemctl stop test_seabee</code></li> <li>kill KubeArmor: <code>sudo pkill kubearmor</code></li> <li>restart SeaBee: <code>systemctl start test_seabee</code></li> <li>restart KubeArmor: <code>systemctl start kubearmor</code></li> </ul> <p>Before continuing verify that</p> <ul> <li>seabee has our new policy with <code>sudo seabeectl list</code></li> <li>kUbeArmor is running with <code>systemctl status kubearmor</code></li> </ul> <p></p>"},{"location":"policy_tutorial/#policy-scope","title":"Policy Scope","text":"<p>Read about policy scope</p> <p>When creating a policy scope for a tool, there are several important considerations.</p> <ul> <li>the 'core' binary, i.e. <code>kubearmor</code> must be in scope</li> <li>any other binary that needs access to KubeArmor's files or eBPF structures must also be in scope</li> <li>The scope cannot be so broad that it causes unexpected permission denials by protecting things that need to be available. For example, systemd cannot be in scope.</li> <li>The scope generally should not include executables that belong the system (ubuntu) rather than the tool (KubeArmor)</li> </ul> <p>Then what executables should be in scope for KubeArmor?</p> <p>We already have <code>/opt/kubearmor/kubearmor</code> in scope. We will add <code>./bin/karmor</code> since it is used to manage KubeArmor policies. However, we will need an absolute path for a SeaBee policy. Lets copy the <code>karmor</code> client to <code>/usr/local/bin/karmor</code> which should allow us to run it without modifying our PATH.</p> <p><code>sudo cp ./bin/karmor /usr/local/bin/karmor</code></p> <p>verify with <code>sudo karmor probe</code></p> <p>Now we have a new SeaBee policy scope:</p> <pre><code>scope:\n  - /opt/kubearmor/kubearmor\n  - /usr/local/bin/karmor\n</code></pre> <p>We won't add anything else to the scope because it doesn't seem like there are any other binaries that KubeArmor is using.</p>"},{"location":"policy_tutorial/#files","title":"Files","text":"<p>Read about files in SeaBee</p> <p>For each file or directory we put in the SeaBee policy, only the processes in scope will be able to write to them them. This means that if a user or external needs to modify a file for the tool to function, that file and the directory it lives in should not be listed in the SeaBee policy.</p> <p>For KubeArmor, we will start by looking at different classes of files that ought to be protected.</p>"},{"location":"policy_tutorial/#policy-files","title":"Policy files","text":"<p><code>/opt/kubearmor/policies</code> contains the policy we created. You can experiment by deleting this folder and restarting KubeArmor to see that our policy is no longer loaded. This folder should be protected.</p>"},{"location":"policy_tutorial/#configuration-file","title":"Configuration file","text":"<p><code>/opt/kubearmor/kubearmor.yaml</code> contains a configuration file. Mine looks like this:</p> <pre><code>cluster: \"default\"\ngRPC: \"32767\"\nhostVisibility: \"process,file,network,capabilities\"\nenableKubeArmorHostPolicy: true\nenableKubeArmorVm: false\nk8s: false\nalertThrottling: true\nmaxAlertPerSec: 10\nthrottleSec: 30\n</code></pre> <p>Noticing that <code>enableKubeArmorHostPolicy</code> is set to true, I tried switching it to false and restarting KubeArmor. I this causes KubeArmor to load, but no longer enforce policies. However, this configuration change did appear in KubeArmor logs both during startup and at runtime.</p> <p><code>journalctl -u kubearmor -f</code></p> <pre><code>Oct 23 18:24:09 ubuntu kubearmor[2786276]: 2025-10-23 18:24:09.784295        INFO        setting config from file [kubearmor.yaml]\n\n\nOct 23 18:24:09 ubuntu kubearmor[2786276]: 2025-10-23 18:24:09.784441        INFO        Configuration [{... Policy:false HostPolicy:false...}]\n</code></pre> <p>Given the security implications of this configuration file, SeaBee should probably protect it.</p>"},{"location":"policy_tutorial/#log-files","title":"Log files","text":"<p>KubeArmor logs exist in two places.</p> <ol> <li>the journal, which is managed by systemd and does not need to be protected by SeaBee</li> <li>the security events logs with that can be seen with <code>karmor logs --gRPC=:32767</code> These logs are not stored by default, but can be configured to be stored on disk with <code>--logPath</code> option.</li> </ol> <p>For our use case, we will not add a KubeArmor log path, so no action is needed to protect KubeArmor log files. However, if you were going to write logs to disk, it might make sense to protect <code>/var/log/kubearmor/</code> or a similar location with SeaBee.</p>"},{"location":"policy_tutorial/#other-files","title":"other files","text":"<p>I tried deleting <code>/opt/kubearmor/BPF</code> and KubeArmor failed to start. This folder should be protected since KubeArmor relies on it. Fixing this required re-installing KubeArmor.</p> <p>I haven't look at <code>/opt/kubearmor/templates</code>, but since everything else in <code>/opt/kubearmor/</code> seems important to KubeArmor, se will protect the entire <code>/opt/kubearmor/</code> directory.</p>"},{"location":"policy_tutorial/#updating-our-policy-again","title":"Updating our policy again","text":"<pre><code>name: kubearmor-simple-seabee-policy\nversion: 3\nscope:\n  - /opt/kubearmor/kubearmor\n  - /usr/local/bin/karmor\nfiles:\n  - /opt/kubearmor\nconfig:\n  signal_access: audit\n  signal_allow_mask: 0\n</code></pre> <ul> <li>modify: <code>vim kubearmor-simple-seabee-policy.yaml</code></li> <li>sign: <code>sudo seabeectl sign -t kubearmor-simple-seabee-policy.yaml -k rsa-private-key.pem</code></li> <li>update: <code>sudo seabeectl update -t kubearmor-simple-seabee-policy.yaml -s signature.sign</code></li> </ul> <p>The final test of our policy is to verify that KubeArmor is still functioning: <code>systemctl restart kubearmor</code>.</p> <p>After checking <code>kubearmor</code> logs for errors, it seems to work. I also observe that <code>sleep 1</code> is still blocked.</p> <p></p>"},{"location":"policy_tutorial/#config-file_write_access","title":"Config: file_write_access","text":"<p>Read more about SeaBee policy config</p> <p>This will remain as <code>block</code> which is currently the default.</p>"},{"location":"policy_tutorial/#config-include_pins","title":"Config: include_pins","text":"<p>It is clear that KubeArmor crates eBPF pins by doing: <code>ls /sys/fs/bpf</code>. However, it is unclear how these pins are used.</p> <p>It is possible to delete these pins using <code>sudo rm /sys/fs/bpf/&lt;pin_name&gt;</code> if SeaBee is not running. However, KubeArmor still works since these pinned maps still exist in kernel memory. The pin is just a reference to the maps.</p> <p>It is a good assumption that if KubeArmor creates these pins, it probably relies on them to function correctly.</p> <p>We will leave <code>include_pins</code> as the default, which is true. This ensures the pins are protected by SeaBee.</p>"},{"location":"policy_tutorial/#config-map_access","title":"Config: map_access","text":"<p>This will remain as <code>block</code> which is currently the default.</p> <p>This protection is critical to preventing the attack we demonstrated earlier.</p>"},{"location":"policy_tutorial/#config-ptrace_access","title":"Config: ptrace_access","text":"<p>It is possible attach to <code>kubearmor</code> with <code>strace -p &lt;pid&gt;</code>.</p> <p>This means that ptrace access is currently allowed. Ptrace can be use maliciously to manipulate how the <code>kubearmor</code> process works.</p> <p>Since <code>ptrace</code> would only ever be needed for <code>kubearmor</code> for debugging, we will keep it as <code>block</code>, which is the default</p>"},{"location":"policy_tutorial/#conclusions","title":"Conclusions","text":"<p>Since the rest of the protections remain as the default, we have completed our SeaBee policy for KubeArmor.</p> <p>You can see this policy as <code>sample_policy/kubearmor-systemd.yaml</code></p> <pre><code>name: kubearmor-simple-seabee-policy\nversion: 3\nscope:\n  - /opt/kubearmor/kubearmor\n  - /usr/local/bin/karmor\nfiles:\n  - /opt/kubearmor\nconfig:\n  signal_access: audit\n  signal_allow_mask: 0\n  # other options remain as default\n</code></pre>"},{"location":"policy_tutorial/#5-next-steps","title":"5. Next Steps","text":"<p>Thats All!</p> <p>If you have more questions about SeaBee, please reach out to us on GitHub.</p> <p>We always welcome issues, feature requests, and contributions.</p> <pre><code># cleanup\nsystemctl stop test_seabee\nsystemctl stop kubearmor\n\nrm /usr/local/bin/karmor\nrm hostpolicy.yaml\nrm kubearmor-simple-seabee-policy.yaml\nrm signature.sign\nrm rsa-private-key.pem\nrm rsa-public-key.pem\n\nsudo apt remove kubearmor\n\nsudo seabeectl clean policy\nsudo seabeectl clean keys\n</code></pre>"},{"location":"requirements/","title":"SeaBee System Requirements","text":"<p>SeaBee only works on Linux.</p> <p>SeaBee needs root or 'sudo' or run.</p> <p>We specifically run tests to ensure support on the following distributions:</p> <ul> <li>Fedora 41, 42</li> <li>RHEL/Rocky 9</li> <li>Ubuntu 22.04, 24.04</li> </ul> <p>However, in theory, SeaBee should work on any Linux kernel 5.14+ since we do not rely on any features added after 5.14.</p>"},{"location":"requirements/#fedora-41-42","title":"Fedora 41, 42","text":"<p>Should work out of the box</p>"},{"location":"requirements/#rhelrocky-9","title":"RHEL/Rocky 9","text":"<p>Should work out of the box</p>"},{"location":"requirements/#ubuntu-2204-2404","title":"Ubuntu 22.04, 24.04","text":"<p>As of Ubuntu 24.04, Ubuntu has the kernel config option <code>CONFIG_BPF_LSM</code>, but it does not enable BPF LSM by default. We must enable it in order for this code to work.</p> <pre><code># get current LSM list\nsudo cat /sys/kernel/security/lsm\n# edit new GRUB config stub\nsudo vim /etc/default/grub.d/99-bpf-lsm.cfg\n# add a line with \",bpf\" at the end with the current LSM list preceding, something like\n# GRUB_CMDLINE_LINUX_DEFAULT=\"${GRUB_CMDLINE_LINUX_DEFAULT} lsm=lockdown,capability,landlock,yama,apparmor,bpf\"\n#\n# update GRUB config\nsudo update-grub\n# reboot and check LSM list again\nsudo reboot\nsudo cat /sys/kernel/security/lsm\n# If you see 'bpf' in the list, then you are good to go!\n</code></pre>"},{"location":"requirements/#other-distributions","title":"Other Distributions","text":"<p>If you have tested SeaBee on another distribution/environment, and have instructions for how you did it, please create a PR so we can add those steps to our documentation and benefit anyone who wants to use SeaBee!</p>"},{"location":"seabeectl/","title":"<code>seabeectl</code>","text":"<p><code>seabeectl</code> is a command line client for the SeaBee daemon. <code>seabeectl</code> sends requests to the SeaBee daemon and returns responses to the user. These requests include things such as updating policy, adding keys, and turning off SeaBee. <code>seabeectl</code> also has various convenient features that don't interact with the SeaBee daemon such as signing SeaBee policies and some testing/debugging commands.</p> <p><code>seabeectl</code> does it best to be self-documenting with <code>seabeectl --help</code> or <code>seabeectl &lt;command&gt; --help</code>. This documentation gives and overview of <code>seabeectl</code> and may explain in more detail that tool's help menu.</p>"},{"location":"seabeectl/#seabeectl-alg","title":"<code>seabeectl alg</code>","text":"<p>This will always display up to date information about what cryptographic algorithms are supported.</p> <p>example: <code>sudo seabeectl alg</code></p> <p>Currently SeaBee supports RSA and ECDSA keys. We also support SHA-2 and SHA-3 message digests. SeaBee also expects keys to be in <code>.pem</code> format.</p> <p>PQC support will be added with issue 42.</p> <p>If cryptographic support is a barrier for using SeaBee please create an issue and we can add support for more algorithms.</p>"},{"location":"seabeectl/#seabeectl-sign","title":"<code>seabeectl sign</code>","text":"<p>Sign a target file with a private signing key.</p> <p>example: <code>sudo seabeectl sign -t tests/policies/sample_policy.yaml -k seabee-root-private-key.pem</code></p> <ul> <li><code>-t</code> to specify a path to a file that should be signed</li> <li><code>-k</code> the path to a key to a signing key</li> <li><code>-o</code> the path the signature file should be output to</li> <li><code>-d</code> an algorithm used to compute the message digest (default: SHA3-256)</li> <li><code>-n</code> don't prompt for a password, only use for unencrypted signing keys which is insecure</li> </ul> <p>This uses the rust openssl crate to sign a target file.</p>"},{"location":"seabeectl/#seabeectl-verify","title":"<code>seabeectl verify</code>","text":"<p>Verify a signature on a file with a public verification key.</p> <p>example: <code>sudo seabeectl verify -t tests/policies/sample_policy.yaml -s signature.sign -k /etc/seabee/seabee_root_key.pem</code></p> <ul> <li><code>-t</code> the file for which the signature was generated</li> <li><code>-s</code> the signature for the file</li> <li><code>-k</code> the path to the public verification key</li> <li><code>-d</code> the digest used to generate the signature if not using the default (SHA3-256)</li> </ul> <p>This uses the rust openssl crate to verify a target file.</p> <p>This command is mostly used for testing and experimentation. It uses the same underlying logic as SeaBee to verify files.</p>"},{"location":"seabeectl/#seabeectl-clean","title":"<code>seabeectl clean</code>","text":"<p>Used to clean up SeaBee files. Use with caution, this will delete saved keys, policies, signatures, and configs.</p> <p>example: <code>sudo seabeectl clean policy</code></p> <p>This command can only be used while SeaBee is turned off. This is because it deletes saved SeaBee files. Whenever a policy or key is added, SeaBee will save it to <code>/etc/seabee</code>. This allows SeaBee to reload keys or policies when the system reboots. While SeaBee is running, these files cannot be modified.</p> <ul> <li><code>policy</code> deletes saved policies and their signatures</li> <li><code>keys</code> deletes saved keys and signatures</li> <li><code>root-key</code> deletes the root key. Note that SeaBee needs a root key in order to run.</li> <li><code>config</code> deletes the saved SeaBee config.</li> <li><code>all</code> does all of the above by deleting <code>/etc/seabee</code></li> </ul>"},{"location":"seabeectl/#seabeectl-config","title":"<code>seabeectl config</code>","text":"<p>Add, update, or delete the saved SeaBee config.</p> <p>example: <code>sudo seabeectl config get</code></p> <p>This command adds convenience for interacting with the SeaBee saved configuration. The saved configuration lives at <code>/etc/seabee/config.yaml</code>. It is important to remember that the SeaBee saved configuration may be different than the actual configuration that SeaBee is using. This is because the any option not specified in the saved configuration will use a default. Also, if command line arguments are used together with saved configuration, then the command line option will take precedence over a saved configuration. For more information about SeaBee configuration, see the config docs.</p> <p>There are three subcommands for <code>seabeectl config</code></p> <ul> <li><code>get</code> dumps the contents of the current saved SeaBee config</li> <li><code>update</code> update the current config with a new one from a file. This just performs a copy and overwrites the existing saved config.</li> <li><code>delete</code> deletes the current saved config.</li> </ul>"},{"location":"seabeectl/#seabeectl-shutdown-request","title":"<code>seabeectl shutdown-request</code>","text":"<p>Generate a SeaBee shutdown request for this machine.</p> <p>example: <code>seabeectl shutdown-request /path/to/shutdown_request.yaml</code></p> <p>By default, the file will be created as <code>shutdown_request.yaml</code> in the current directory. Optionally, a path can be passed to this command as a final argument.</p> <p>See shutdown for how to use the generated file to shutdown SeaBee.</p>"},{"location":"seabeectl/#seabeectl-list","title":"<code>seabeectl list</code>","text":"<p>Shows a list of all currently loaded SeaBee policies</p>"},{"location":"seabeectl/#seabeectl-show","title":"<code>seabeectl show</code>","text":"<p>Displays a single loaded SeaBee policy. This can also be used to check if a particular policy exists.</p> <p>example: <code>seabeectl show name sample-policy</code></p> <p>For this command you will have to choose how to identify the policy</p> <ul> <li>by policy id with <code>id</code></li> <li>by name with <code>name</code></li> <li>by a policy file with <code>file</code></li> </ul>"},{"location":"seabeectl/#seabeectl-update","title":"<code>seabeectl update</code>","text":"<p>Takes a policy file as an argument and adds it to SeaBee if a policy with the same name does not exist or updates a policy if it does exist.</p> <p>example: <code>sudo seabeectl update -t tests/policies/sample_policy.yaml -s signature.sign</code></p> <p>note: this example may fail if you have not yet done <code>sudo mkdir /etc/test_seabee_policy</code></p> <ul> <li><code>-t</code> is the path to the policy you are adding</li> <li><code>-s</code> is the signature for that policy</li> <li><code>-d</code> is the message digest used for the signature (only if you are not using the default)</li> </ul> <p>If <code>--verify-policy</code> is enabled, which is necessary for security, then this command requires a signature for the policy. The crypto docs explains how to sign and load a SeaBee policy. Basically, you need to create a public key pair, add the public key to SeaBee with <code>seabeectl add-key</code>, sign the policy with <code>seabeectl sign</code>, then add the policy with <code>seabeectl update</code>.</p> <p>If the signature was not generated using the default message digest (SHA3-256), then you will need to use the <code>-d</code> option to specify the digest algorithm. This ensures that the signature can be properly verified.</p> <p>All files or directories specified in a policy must exist on policy load.</p> <p>The scope of a policy cannot be changed via a policy update. This is partially due to implementation limitations, but also from intuition. The scope defines where the policy applies. Changing the scope intuitively suggests that a new policy is being created.</p> <p>Policy updates require the version number to be increased. This prevents an attacker from trying to load an older version of the same policy, which may be less secure. It ensures that a new signature is always needed to update policy. You can view the current version number for a policy with with <code>seabeectl show</code> or <code>seabeectl list</code></p>"},{"location":"seabeectl/#seabeectl-remove","title":"<code>seabeectl remove</code>","text":"<p>This is used to remove a SeaBee policy.</p> <p>example: <code>sudo seabeectl remove -t tests/policies/remove_sample_policy.yaml -s signature.sign</code></p> <ul> <li><code>-t</code> the path to a SeaBee remove request</li> <li><code>-s</code> signature for the remove request, must be signed by same key as the policy being removed</li> <li><code>-d</code> as with all signed requests, the digest is needed if the default is not being used</li> </ul> <p>A SeaBee remove request only includes the name and version of the policy to be removed.</p> <pre><code># Example remove request\nname: sample-policy\nversion: 1\n</code></pre> <p>The remove request is important because it ensures that the signature for removing a policy is different from the signature for adding a policy.</p> <p>To explain why this is important, more context is needed/ When a SeaBee policy is added, its signature is saved. Anyone can view these signatures at <code>/etc/seabee/policy_sigs</code>. This means an attacker has access to the policy files and valid signatures for those files. If the signature for removing a SeaBee policy was the same as the signature for adding, then an attacker could remove any SeaBee policy.</p>"},{"location":"seabeectl/#seabeectl-list-keys","title":"<code>seabeectl list-keys</code>","text":"<p>Lists all of the keys currently added to SeaBee.</p> <p>example: <code>sudo seabeectl list-keys</code></p> <p>Specifically, for each key it will display:</p> <ul> <li><code>Added from:</code> file path were the key was added from</li> <li><code>id:</code> unique numerical identifier for the key</li> <li><code>Type:</code> the type of key</li> <li><code>Size:</code> the length of the key</li> </ul>"},{"location":"seabeectl/#seabeectl-show-key","title":"<code>seabeectl show-key</code>","text":"<p>Displays a single SeaBee key. This can also be used to specify if a particular key exists.</p> <p>example: <code>sudo seabeectl show-key id 0</code></p> <p>note: id 0 is always the root key</p> <p>You can search for a key using the following fields:</p> <ul> <li><code>id</code>: the unique numerical identifier that SeaBee assigns for the key</li> <li><code>file</code>: SeaBee will load a key from the path specified and check if the key at that path matches any key that SeaBee has saved.</li> </ul>"},{"location":"seabeectl/#seabeectl-add-key","title":"<code>seabeectl add-key</code>","text":"<p>Add a new verification key to SeaBee.</p> <p>example: <code>sudo seabeectl add-key -t new-seabee-public-key.pem</code></p> <p>options for this command include</p> <ul> <li><code>-t</code> the path to the key being added</li> <li><code>-s</code> a signature for the key from the root key. Only required if <code>--verify-keys</code> enabled in SeaBee config</li> <li><code>-d</code> the digest used by signature if it doesn't use the default (SHA3-256)</li> </ul> <p>Use <code>seabeectl alg</code> to see a list of supported cryptographic algorithms and key formats</p>"},{"location":"seabeectl/#seabeectl-remove-key","title":"<code>seabeectl remove-key</code>","text":"<p>Remove a SeaBee key.</p> <p>example: <code>seabeectl remove-key -t new-seabee-public-key.pem -s signature.sign</code></p> <p>Options for this command include</p> <ul> <li><code>-t</code> the path to the key being removed</li> <li><code>-s</code> the path to a signature of the key file from the corresponding private key or the root key</li> <li><code>-d</code> the digest used by signature if it doesn't use the default (SHA3-256)</li> </ul> <p>Removing a key requires passing a path to the key file (pem) and a valid signature for that file. The signature must be verified using the key itself or the SeaBee root key. Removing a key does not automatically revoke any polices that were signed by that key. Instead, during reboot, all policies are reloaded and re-verified. The removal of a key may cause some policies to generate verification errors on reboot. The SeaBee root key cannot be removed, it can only be changed while SeaBee is turned off.</p>"},{"location":"seabeectl/#seabeectl-shutdown","title":"<code>seabeectl shutdown</code>","text":"<p>Shutdown SeaBee with a shutdown request.</p> <p>example: <code>sudo seabeectl shutdown -t shutdown_request.yaml -s shutdown_signature.sign</code></p> <p>The shutdown request is a YAML file with Linux machine id from <code>/etc/machine-id</code>. This file can be generated with <code>seabeectl shutdown-request</code>. The shutdown request must be signed with the SeaBee root key.</p> <p>Options for this command include</p> <ul> <li><code>-t</code> the path to the shutdown request file</li> <li><code>-s</code> the path to the signature for the shutdown request</li> <li><code>-d</code> the digest used by signature if it doesn't use the default (SHA3-256)</li> </ul>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#attack-surface","title":"Attack Surface","text":"<p>The system is made up of several parts and attacks are considered against each of them.</p> <ol> <li>Userspace process</li> <li>eBPF programs &amp; pins</li> <li>eBPF maps</li> <li>Attacks that circumvent the access control model</li> </ol>"},{"location":"testing/#test-goals","title":"Test Goals","text":"<ol> <li>Correct functionality: the system works as desired</li> <li>Safety: the system is protected from adversaries<ul> <li>Malicious root processes</li> <li>Other eBPF programs</li> </ul> </li> </ol>"},{"location":"testing/#test-filtering","title":"Test Filtering","text":"<p>If you are having trouble with a particular test and only want to run it   or a subset of tests, then you can use a filter on the command line.</p> <p>For instance, when in the <code>seabee</code> folder:</p> <pre><code>export CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUNNER='sudo -E'\ncargo test --test integration_test -- &lt;filter&gt;\n</code></pre> <p>Where <code>&lt;filter&gt;</code> is replaced by the name of the test you want to run,   i.e. <code>security_kmod</code>.</p> <p>Similarly, if you need to skip a test because it has a known failure,   you can skip it using the <code>--skip &lt;filter&gt;</code> option:</p> <pre><code>export CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUNNER='sudo -E'\ncargo test --test integration_test -- --skip &lt;filter&gt;\n</code></pre>"},{"location":"testing/#test-structure","title":"Test Structure","text":""},{"location":"testing/#testsuite-trait-and-derivatives","title":"TestSuite trait (and derivatives)","text":"<p>Located under <code>tests/src/suite.rs</code></p> <p>This trait has been developed to closely mimic how <code>pytest</code> fixtures work. All tests should try to use the <code>TestSuite</code> structure when possible as it   has the infrastructure necessary to provide shared state between tests   via its <code>get_args()</code> function. The exception are simple tests and tests that don't need shared state   such as the Daemon and Fork tests.</p> <p>There are currently three implementations of TestSuite:</p> <ul> <li><code>seabee/tests/functional/mod.rs</code></li> <li><code>seabee/tests/security/mod.rs</code></li> <li><code>tests/src/functional/mod.rs</code></li> </ul>"},{"location":"testing/#bpfstate","title":"BPFState","text":"<p>Located under <code>tests/src/state/mod.rs</code></p> <p><code>BPFState</code> is a generic structure that has been defined to summarize   information gleaned from a BPF userspace including maps and pins.</p> <p>The default <code>TestArgs</code> structure in <code>TestSuite</code> contains three instances of   <code>BPFState</code>:</p> <ul> <li>Rust - Information from the perspective of a BPF file-descriptor owner</li> <li>Linux - Information from the perspective of a Linux superuser</li> <li>Ground Truth - Information provided by the test writer</li> </ul> <p>The <code>check_args()</code> function in the <code>TestSuite</code> trait will check whether the   <code>BPFState</code> was manipulated during the tests.</p>"},{"location":"testing/#generic-functional-tests","title":"Generic Functional Tests","text":"<p>Located under <code>tests/src/functional/mod.rs</code></p> <p>A generic functional test library has been developed under <code>tests/src/functional</code>. Any BPF userspace can run these tests so long as they use the <code>BPFUserspace</code>   structure defined in the <code>bpf</code> crate. They also depend on ground truth to be defined in a TOML file, see the   <code>seabee/tests/ground_truth.toml</code> for an example.</p> <p>The following types of tests are implemented for checking correct functionality:</p> <ul> <li>Maps<ul> <li>Existence</li> <li>Contents</li> </ul> </li> <li>Pins<ul> <li>Existence</li> <li>Correct directory</li> <li>Contents</li> </ul> </li> <li>Userspace<ul> <li>Existence</li> </ul> </li> </ul>"},{"location":"testing/#seabee","title":"SeaBee","text":"<p>Integration tests are defined in <code>seabee/tests/integration_tests.rs</code>.</p>"},{"location":"testing/#daemon","title":"Daemon","text":"<p>Daemon tests are in <code>seabee/tests/daemon_test.rs</code> and ran separately from the   tests defined in <code>seabee/tests/integration_tests.rs</code>.</p> <p>These tests verify properties specific to <code>systemd</code>.</p>"},{"location":"testing/#functional","title":"Functional","text":"<p>Correct functionality is tested via the generic functional tests which   is extended via a SeaBee specific TestSuite defined under   <code>seabee/tests/functional/mod.rs</code> which includes a test to   check that the correct inode and device id information is used within   the <code>protected_pins</code> map.</p>"},{"location":"testing/#security","title":"Security","text":"<p>Safety is tested via the SeaBee security tests located under   <code>seabee/tests/security/mod.rs</code>. These tests verify that the userspace and associated BPF programs and maps cannot be manipulated once the SeaBee protections are in place.</p>"},{"location":"threat_model/","title":"Threat Model","text":"<p>An important question with any security project is to define the threat model:</p> <p>What are we trying to protect from and what are we not trying to protect.</p> <p>This project aims to protect a userspace process   and its eBPF programs from anything a privileged user   can do to interrupt it. Examples include:</p> <ul> <li>Signals that would kill the userspace program</li> <li>Ptrace on the userspace program</li> <li>Unauthorized eBPF map access and manipulation</li> <li>Deletion of pinned eBPF programs and eBPF maps</li> <li>Trusted loading of kernel modules*</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Help! Something is broken!</p> <p>If you don't find a solution here, please create an issue on our GitHub, we apologize this project is still under active development.</p>"},{"location":"troubleshooting/#is-seabee-failing-to-build","title":"Is SeaBee Failing to build?","text":""},{"location":"troubleshooting/#missing-a-dependency","title":"missing a dependency","text":"<p>something may have gone wrong with the <code>update_dependencies.sh</code> script.</p> <p>Try running <code>make udpate</code> again</p>"},{"location":"troubleshooting/#bpftool-not-found","title":"bpftool not found","text":"<p>The following error occurs with how <code>bpftool</code> is installed on ubuntu. <code>bpftool</code> needs to match the underlying kernel version. If you recently ran <code>apt upgrade</code> or <code>make update</code>, you may have installed a new kernel version. You should reboot into that new kernel and recompile SeaBee for the newer kernel.</p> <pre><code>WARNING: bpftool not found for kernel 5.15.0-144\n    You may need to install the following packages for this specific kernel:\n      linux-tools-5.15.0-144-generic\n      linux-cloud-tools-5.15.0-144-generic\n    You may also want to install one of the following packages to keep up to date:\n      linux-tools-generic\n      linux-cloud-tools-generic\n  Error: failed to generate vmlinux.h: failed to generate vmlinux using bpftool: exit status: 2\n</code></pre>"},{"location":"troubleshooting/#issues-with-kernel-modules","title":"Issues with kernel modules","text":"<p>Most of the issues with kernel modules can be solved by recompiling the kernel modules or rebooting.</p> <ul> <li><code>make clean</code> and <code>make test</code></li> <li><code>sudo reboot</code></li> </ul> <p>Some errors I've encountered and fix this way:</p> <pre><code># Failing to load kernel modules during testing\nmodprobe: ERROR: could not insert 'test_kmod': Operation not permitted\n</code></pre> <p>Issue 11 and Issue 36 are related to kernel modules.</p>"},{"location":"troubleshooting/#seabee-wont-turn-off","title":"SeaBee won't turn off","text":"<ul> <li>check with <code>systemctl status &lt;daemon_name&gt;</code> or with <code>ps -aux | grep seabee</code></li> </ul> <p>If so, we will need to shut it off. If SeaBee is running with the <code>--sigint allow</code> option, then we can kill it with <code>sudo kill -2 &lt;Pid&gt;</code> or <code>systemctl stop &lt;daemon_name&gt;</code>.</p>"},{"location":"troubleshooting/#seabee-state-corrupted","title":"SeaBee state corrupted","text":"<p>There may be something wrong with the internal state of SeaBee, if so, we can clean it up with <code>seabeectl clean</code></p> <ul> <li><code>sudo seabeectl clean --help</code></li> </ul> <p>To do a hard reset of SeaBee data, use <code>sudo seabeectl clean all</code></p> <p>This will remove all keys, policies, the root key, configurations, ect.</p> <p>Once that is done, you should be able to use the getting started instructions to get SeaBee working again from scratch.</p>"},{"location":"troubleshooting/#checking-the-seabee-logs","title":"Checking the SeaBee Logs","text":"<p>See logging</p>"},{"location":"tutorial/","title":"SeaBee Tutorial","text":"<p>This tutorial  is intended to walk through the different features of SeaBee and how they work. It should only take a few minutes.</p> <p>This tutorial assumes you have already completed getting started</p> <p>If you run into issues, see troubleshooting</p>"},{"location":"tutorial/#starting-up-seabee","title":"Starting up SeaBee","text":"<p>While seabee is running, we can use <code>seabeectl</code> to interact with it. You can learn all about <code>seabeectl</code> in our seabeectl documentation.</p> <p>If you've already run the SeaBee test cases, then the test daemon is already installed. We will run the SeaBee test daemon and interact with it to see how SeaBee works.</p> <ul> <li><code>systemctl start test_seabee</code> to start the daemon</li> <li><code>systemctl status test_seabee</code> to make sure it is \"active (running)\"</li> </ul> <p>Finally, if you want to see the <code>seabee</code> logs when it is running as a daemon, you can view them in the journal: <code>journalctl -u test_seabee -f</code></p> <p></p>"},{"location":"tutorial/#seabee-policy","title":"SeaBee Policy","text":"<p>List any seabee policies with: <code>sudo seabeectl list</code></p> <p>We don't have any policies yet, so lets add one. Lets ask seabeectl for help: <code>sudo seabeectl --help</code></p> <p></p> <p>It looks like the command we need is called <code>update</code>. Lets find out more: <code>sudo seabeectl update --help</code></p> <p></p> <p>It looks like we need to give <code>seabeectl</code> a path to a policy file with the <code>-t</code> option. You can learn more about creating SeaBee policies and how they work in out policy documentation. For now, lets use a sample policy file:</p> <p>view the policy: <code>cat tests/policies/sample_policy.yaml</code></p> <pre><code>---\nname: sample-policy\nversion: 1\nscope:\n  - /usr/bin/vi\nfiles:\n  - /etc/test_seabee_policy\nconfig:\n  # audit access to eBPF maps in scope\n  map_access: audit\n  # block writes to files by out-of-scope processes\n  file_write_access: block\n  # block writes to eBPF pins in addition to other files\n  include_pins: true\n  # audit ptrace on /usr/bin/vi\n  ptrace_access: audit\n  # audit all signals to /usr/bin/vi\n  signal_access: audit\n  signal_allow_mask: 0x0\n</code></pre> <p>This file has come comments to help you understand what it does. Normally policy files would target an eBPF application, but for this tutorial we will use the <code>vi</code> editor for demonstration.</p> <p>add the policy: <code>sudo seabeectl update -t tests/policies/sample_policy.yaml</code></p> <p></p> <p>Uh Oh! It looks like we got an error because <code>/etc/test_seabee_policy</code> does not exist. SeaBee policies apply protections to files on policy load. This means that all files or directories specified in the policy must exist when the policy is loaded. Files created at runtime can be protected if they are created in a protected directory. See issue #35 for more.</p> <p>Fortunately, the error message gives us some ideas for how to resolve this issue: <code>sudo mkdir /etc/test_seabee_policy</code></p> <p>Now try again: <code>sudo seabeectl update -t tests/policies/sample_policy.yaml</code></p> <p></p> <p>Looks like we got a verification failure because we didn't give a signature for our policy. SeaBee uses signatures to authorize policies updates and removals. This is how SeaBee moves trust away from privileged users and instead towards cryptographic keys.</p> <p>The next section looks into how to create keys and sign policies.</p>"},{"location":"tutorial/#creating-a-key","title":"Creating a Key","text":"<p>In order for SeaBee to accept a policy, it needs to know the policy is authentic. This requires us to create a key and tell SeaBee to trust it. To learn more about how the crypto works, read our crypto documentation.</p> <p><code>seabeectl</code> can tell us what kind of keys are supported: <code>sudo seabeectl alg</code></p> <p>We will use an RSA key for this tutorial. Openssl is popular library for cryptography that we are going to use. Start by checking that <code>openssl</code> is installed: <code>openssl version</code></p> <p>If it is not installed, you can install it with your package - manager.</p> <ul> <li><code>sudo dnf install openssl openssl-devel</code> (Fedora/RHEL)</li> <li><code>sudo apt-get install openssl libssl-dev</code> (Debian/Ubuntu)</li> </ul> <p>Now we can create our RSA key pair:</p> <ul> <li>create private rsa key: <code>openssl genpkey -aes256 -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out rsa-private-key.pem</code></li> <li>create corresponding public rsa key: <code>openssl pkey -in rsa-private-key.pem -out rsa-public-key.pem -pubout</code></li> </ul> <p>Remember that its important to encrypt private keys and even better: generate, store, and use them on a separate secure system from where signature verification will take place. For this tutorial, we are just learning and these keys don't need to be kept extra secure.</p>"},{"location":"tutorial/#signing-a-policy","title":"Signing a Policy","text":"<p>Now lets use our new private key to sign our policy. While you can do this with openssl, <code>seabeectl</code> can do it too: <code>sudo seabeectl sign --help</code></p> <p>Use the <code>sign</code> command: <code>sudo seabeectl sign -t tests/policies/sample_policy.yaml -k rsa-private-key.pem</code></p> <p>Lets also check by using <code>seabeectl</code> to verify our signature</p> <ul> <li><code>sudo seabeectl verify --help</code></li> <li><code>sudo seabeectl verify -t tests/policies/sample_policy.yaml -s signature.sign -k rsa-public-key.pem</code></li> </ul> <p></p> <p>We have now successfully created a signature for our policy.</p>"},{"location":"tutorial/#adding-a-key-to-seabee","title":"Adding a Key to SeaBee","text":"<p>Before we add our policy, we still need SeaBee to trust our public key. To see how that's done, ask <code>seabeectl</code> for help again: <code>sudo seabeectl add-key --help</code></p> <p>SeaBee can allow anyone to add policies, or only those authorized by the administrator (<code>--verify-keys</code> configuration option). By default, anyone can add a verification key. This doesn't really make SeaBee less secure, since you can't update policies signed by a key you don't have. It just makes it easier for users to add their own policies.</p> <p><code>sudo seabeectl add-key -t rsa-public-key.pem</code></p> <p></p> <p>We can check that our key was added with <code>sudo seabeectl list-keys</code>. The key with ID 0 is the root key.</p> <p></p>"},{"location":"tutorial/#adding-a-seabee-policy","title":"Adding a SeaBee Policy","text":"<p>Now that we have a key added, we can finally add our SeaBee policy.</p> <p><code>sudo seabeectl update -t tests/policies/sample_policy.yaml -s signature.sign</code></p> <p></p> <p>Success!</p> <p>Lastly, we can check that our policy was added with <code>sudo seabeectl list</code></p>"},{"location":"tutorial/#testing-a-seabee-policy","title":"Testing a SeaBee Policy","text":"<p>In order to test that our policy works, we should take an action and see that it is denied.</p> <p>Lets try to delete the directory we created: <code>sudo rmdir /etc/test_seabee_policy</code></p> <p></p> <p>Permission denied indicates our policy is working.</p> <p>Additionally, lets check the seabee logs to see the denial: <code>journalctl -u test_seabee -f</code></p> <p></p> <p>At the <code>WARN</code> level, we see the denial of our attend to delete the <code>test_seabee_policy</code> directory. The <code>DEBUG</code> logs also show some of SeaBee's internal actions like labeling files and interacting with the kernel.</p> <p>The default log level is configurable in SeaBee's configuration.</p> <p>We can also test to see that an action is allowed. Since we specified <code>/usr/bin/vi</code> in our policy scope, lets try to open a file with <code>vi</code>.</p> <p><code>sudo vi /etc/test_seabee_policy/testfile.txt</code></p> <p>press <code>i</code> to enter insert mode, type some text, then press <code>Esc</code> and type <code>:wq</code> to save and exit.</p> <p>Now print the file: <code>cat /etc/test_seabee_policy/testfile.txt</code></p> <p></p> <p>This demonstrates how SeaBee policy can protect a process and its files from being modified by an outside application.</p>"},{"location":"tutorial/#creating-a-seabee-policy-for-your-application","title":"Creating a SeaBee Policy for your Application","text":"<p>Feel free to try out the sample <code>vi</code> policy more.</p> <ul> <li>try sending signals to <code>vi</code></li> <li>try deleting the the test file</li> <li>try using <code>strace -p</code> to attach to <code>vi</code></li> <li>try updating the policy</li> </ul> <p>If you want to dive deeper into SeaBee policy, There is a second tutorial for this purpose.</p> <p>SeaBee Policy Tutorial</p>"},{"location":"tutorial/#removing-a-seabee-policy","title":"Removing a SeaBee Policy","text":"<p>In order to remove a policy, you also need a signed request. This prevents anyone from removing a policy, rather, only the user who added a policy is able to remove it.</p> <p>A \"SeaBee Remove Request\" is very simple and only includes the name and version of the policy to remove. The version is important since it helps to prevent replay attacks.</p> <p><code>cat tests/policies/remove_sample_policy.yaml</code></p> <pre><code>---\nname: sample-policy\nversion: 1\n</code></pre> <ul> <li>sign remove request: <code>sudo seabeectl sign -t tests/policies/remove_sample_policy.yaml -k rsa-private-key.pem</code></li> <li>find format for remove command: <code>sudo seabeectl remove --help</code></li> <li>remove: <code>sudo seabeectl remove -t tests/policies/remove_sample_policy.yaml -s signature.sign</code></li> <li>verify the removal: <code>sudo seabeectl list</code></li> </ul> <p></p>"},{"location":"tutorial/#removing-a-seabee-key","title":"Removing a SeaBee Key","text":"<p>Ask SeaBee to tell us how to remove a key: <code>sudo seabeectl remove-key --help</code></p> <p>Since we have verification enabled by default, a signature is needed. In this case, we need to sign the public key with our private key. This is not resistant to replay attacks. In production, once a key is removed, it should not be re-added, instead a new key should be created and added.</p> <ul> <li><code>sudo seabeectl sign -t rsa-public-key.pem -k rsa-private-key.pem</code></li> <li><code>sudo seabeectl remove-key -t rsa-public-key.pem -s signature.sign</code></li> <li>verify removal: <code>sudo seabeectl list-keys</code></li> </ul> <p></p> <p>Now that we have removed our key, the only key left is the root key with ID 0.</p>"},{"location":"tutorial/#shutdown-seabee","title":"Shutdown SeaBee","text":"<p>Finally, we will use a shutdown command to exit SeaBee.</p> <p>When you are running <code>test_seabee</code>, it is possible to turn off SeaBee with <code>systemctl stop test_seabee</code>. However, the when <code>seabee</code> is running in production, is it designed to ignore signals and the <code>systemctl stop</code> command. This is to prevent an attacker from disabling SeaBee. <code>sudo seabeectl shutdown</code> requires a signature from the root key to shutdown SeaBee.</p> <p>To demonstrate how this works, first generate a shutdown request: <code>sudo seabeectl shutdown-request</code>. This will create a file called <code>shutdown_request.yaml</code>.</p> <p><code>cat shutdown_request.yaml</code></p> <pre><code>machine_id: fffffffffffffffffffffffffffffff\n</code></pre> <p>The shutdown request contains a <code>machine_id</code> field that comes from <code>/etc/machine-id</code>. This makes the request unique to this machine.</p> <p>Next, sign the shutdown request: <code>sudo seabeectl sign -t shutdown_request.yaml -k seabee-root-private.pem</code></p> <p>Finally, issue the shutdown command: <code>sudo seabeectl shutdown -t shutdown_request.yaml -s signature.sign</code></p> <p></p> <p>It is important that the shutdown request is deleted after it is used so that an attacker cannot reuse the request to shutdown SeaBee again maliciously.</p> <p>SeaBee shutdown requests are generally used rarely, such as upgrading SeaBee to a new version. If there is a problem with SeaBee it is safer to remove and re-add SeaBee policies rather than shutting Seabee off altogether.</p> <ul> <li><code>rm shutdown_request.yaml</code></li> <li><code>rm signature.sign</code></li> </ul>"},{"location":"tutorial/#conclusion","title":"Conclusion","text":"<p>That is the end of this tutorial!</p> <p>Next, try our follow-up tutorial about creating policies</p> <p>You may want to clean up the artifacts you made:</p> <pre><code>rm rsa-private-key.pem\nrm rsa-public-key.pem\nrm signature.sign\n</code></pre>"},{"location":"tutorial/#commands-reference","title":"Commands reference","text":"<p>Here I've summarized all the commands from this tutorial roughly in order</p> <pre><code># Starting up SeaBee\nsystemctl start test_seabee\nsystemctl status test_seabee\njournalctl -u test_seabee -f\nsudo seabeectl --help\n\n# List SeaBee policy\nsudo seabeectl list\ncat tests/policies/sample_policy.yaml\n\n# Creating a key\nsudo seabeectl alg\nopenssl genpkey -aes256 -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out rsa-private-key.pem\nopenssl pkey -in rsa-private-key.pem -out rsa-public-key.pem -pubout\n\n# Signing a policy\nsudo seabeectl sign -t tests/policies/sample_policy.yaml -k rsa-private-key.pem\nsudo seabeectl verify -t tests/policies/sample_policy.yaml -s signature.sign -k rsa-public-key.pem\n\n# Adding a key\nsudo seabeectl add-key -t rsa-public-key.pem\nsudo seabeectl list-keys\n\n# Adding a policy\nsudo seabeectl update -t tests/policies/sample_policy.yaml -s signature.sign\nsudo seabeectl list\n\n# Removing a policy\ncat tests/policies/remove_sample_policy.yaml\nsudo seabeectl sign -t tests/policies/remove_sample_policy.yaml -k rsa-private-key.pem\nsudo seabeectl remove -t tests/policies/remove_sample_policy.yaml -s signature.sign\nsudo seabeectl list\n\n# Shutdown SeaBee\nsudo seabeectl shutdown-request\nsudo seabeectl sign -t shutdown_request.yaml -k seabee-root-private.pem\nsudo seabeectl shutdown -t shutdown_request.yaml -s signature.sign\n\n# Removing a key\nsudo seabeectl sign -t rsa-public-key.pem -k rsa-private-key.pem\nsudo seabeectl remove-key -t rsa-public-key.pem -s signature.sign\nsudo seabeectl list-keys\n</code></pre>"},{"location":"assets/rust/static.files/SourceSerif4-LICENSE-a2cfd9d5/","title":"SourceSerif4 LICENSE a2cfd9d5","text":"<p>Copyright 2014-2021 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries. Copyright 2014 - 2023 Adobe (http://www.adobe.com/), with Reserved Font Name \u2018Source\u2019. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.</p> <p>This Font Software is licensed under the SIL Open Font License, Version 1.1.</p> <p>This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL</p>"},{"location":"assets/rust/static.files/SourceSerif4-LICENSE-a2cfd9d5/#sil-open-font-license-version-11-26-february-2007","title":"SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007","text":"<p>PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.</p> <p>The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.</p> <p>DEFINITIONS \"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.</p> <p>\"Reserved Font Name\" refers to any names specified as such after the copyright statement(s).</p> <p>\"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s).</p> <p>\"Modified Version\" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.</p> <p>\"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.</p> <p>PERMISSION &amp; CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:</p> <p>1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.</p> <p>2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.</p> <p>3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.</p> <p>4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.</p> <p>5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.</p> <p>TERMINATION This license becomes null and void if any of the above conditions are not met.</p> <p>DISCLAIMER THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.</p>"}]}