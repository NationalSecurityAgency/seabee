searchState.loadedDescShard("seabee", 0, "The configuration for SeaBee\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe map handles shared between skeletons\nLoad all of the eBPF programs in the desired configuration.\nThe loaded and running skeleton\nParser-complete configuration\nThe level of protection desired\nNo protection\nNo protection but audit\nFull protection and audit\nProcesses configuration information in the order specified …\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to create Self from the raw representation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHow should SeaBee handle kernel modules?\nAllows some event types to be filtered out\nSpecify the minimum log level that should be printed\nTells how SeaBee should protect itself\nsets up ctrl+c handler based on whether or not SIGINT is …\nCan SIGINT(2) be sent to SeaBee?\nWill only be true during test cases\nIs signature verification for new keys enabled?\nIs signature verification for policies enabled?\nThe path to the bpf filesystem\nThe default path to the configuration file\nThe path where a list of keys is stored\nThe directory to store verification keys\nThe directory to store key signatures\nThe default directory name for pins in the BPF filesystem\nThe directory to store policy files\nThe directory to store policy signatures\nThe path to the seabeectl executable\nThe default directory for seabee files\nThe max number of maps SeaBee can track concurrently. …\nThe max number of policies seabee can store. Should be …\nThe max number of scopes for seabee policies.\nThe location of the SeaBee root key, which is the first …\nThe /sys filesystem\nSHA3: NIST FIPS 202 SHA2: NIST FIPS 180-4\nAn iterator over the variants of SeaBeeDigest\nA key used to verify SeaBeePolicy Updates\nInformation needed to sign a policy\nInformation needed to verify a policy. Note that this is …\nMessage digest algorithm used to sign, overrides digest …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to create Self from the raw representation\nThe id used to identify this key\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe key itself, see <code>openssl::pkey::Pkey</code>\nPath to a pem file containing a verification key\nCreate a new SeaBeeKey from a path and an id\nThe path on disk where this key is saved\nThe digest used to sign this key\nThe path on disk where the signature for this key is saved\nPath the signature for the policy\nPath to a policy to verify\nTwo SeaBeeKeys are equal if they are both RSA and have the …\nTries to match u32 to a discriminant value for a …\nverify a file given a signature, digest algorithm, and key …\nverify a file through the cli using VerifyInfoCLI struct\nadd a new policy to SeaBee and to the kernel, but does not …\nSeaBee base policy (the policy that protects SeaBee itself)\noverwrites all existing policies with policy from policy …\nReturns the argument unchanged.\nAllows test cases to run correctly with policy turned on …\nO(n) operation that returns the corresponding SeaBeeKey if …\nreturns a new key id that does not yet exist\nreturns a policy id that has not yet been used TODO: …\nExecute a SocketCommand from seabeectl\nCalls <code>U::from(self)</code>.\nRemoves a policy from SeaBee, the SeaBee policy folder, …\nwrapper around crypto::verify_file_signature\nMinimum amount of information needed to remove a policy. …\nInformation needed to shutdown seabee\nSecurity level for files and pins\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUniquely identifies a policy file and corresponds to name\nWether or not pins should be tracked by SeaBee\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSelect map security level\nUniquely identifies a policy file\nDetermines if how ptrace can be used on processes in scope\nDetermines how to apply signal mask\nDetermines which signals should be allowed\nChecks for a runtime policy update command and executes it …\nAdd a new verification key\nList supported cryptographic algorithms\nRemove all SeaBee saved data\nRemove SeaBee policies and keys.\nControl the saved SeaBee Config\nRemove the SeaBee saved config\nIdentify by a file path\nIdentify by a file path\nGet the current saved config from /etc/seabee/config.yaml\nIdentify by Id\nIdentify by Id\nRemove all saved SeaBee keys. Policies may not verify on …\nList all currently loaded policies\nList all SeaBee verification keys\nSign and verify policies locally\nIdentify by name\nDifferent ways to uniquely identify a SeaBee Object. Path …\nRemove all saved SeaBee policies\nRemove the current SeaBee saved config\nRemove an existing policy with a remove request.\nRemove an existing verification key\nRemove the SeaBee root key. SeaBee will not start without …\nUsed to query or modify seaBee policies\nDisplay a single loaded policy\nShow a single SeaBee verification key\nShutdown SeaBee with a signed shutdown request\nGenerate a shutdown request\nSign a policy with a private signing key\nInfo needed to add, update, or remove a policy or key\nView, add, update, or remove SeaBee policies\nUpdate the current saved config while SeaBee is turned off\nAdd or update a policy from a path.\nTest verifying a policy with a public verification key\nSpecify the digest for the signature if not using the …\nExecutes the command passed to the command line that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA valid signature for the object, needed if verification …\nDepending on the type of request, this can be a path to a …\nGlobal OnceLock to hold the machine-id string.\nCheck if the process is running with uid 0\nGenerates a mask of allowed signals\nInitialize MACHINE_ID from <code>/etc/machine-id</code> if it isn’t …\ntry to open a file for reading, but create the file if it …\nConverts a path to a u8 vector with a requested max size\nError if file does not have extensions in list of …\nEnsure the system has all requirements for running ebpf …\nCheck that seabee programs have been unloaded\nTraverse all files and directories under <code>root</code>, calling <code>f</code> …")