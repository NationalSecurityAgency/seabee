<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SeaBee: /__w/seabee/seabee/bpf/src/seabee/seabee.bpf.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SeaBee
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7e46271e71bceff8cce0f28c9873f6df.html">bpf</a></li><li class="navelem"><a class="el" href="dir_c75ad9c7aab4ddc9105ba1f9fe057a73.html">src</a></li><li class="navelem"><a class="el" href="dir_744d7f4b771e49251f50eeb95e08ad38.html">seabee</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">seabee.bpf.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;bpf/vmlinux.h&gt;</code><br />
<code>#include &lt;bpf/vmlinux_features.h&gt;</code><br />
<code>#include &lt;bpf/bpf_helpers.h&gt;</code><br />
<code>#include &lt;bpf/bpf_tracing.h&gt;</code><br />
<code>#include &lt;bpf/bpf_core_read.h&gt;</code><br />
<code>#include &quot;<a class="el" href="logging_8h_source.html">logging.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="logging__types_8h_source.html">logging_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="seabee__log_8h_source.html">seabee_log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="seabee__maps_8h_source.html">seabee_maps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="seabee__utils_8h_source.html">seabee_utils.h</a>&quot;</code><br />
<code>#include &quot;shared_rust_types.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for seabee.bpf.c:</div>
<div class="dyncontent">
<div class="center"><img src="seabee_8bpf_8c__incl.png" border="0" usemap="#a_2____w_2seabee_2seabee_2bpf_2src_2seabee_2seabee_8bpf_8c" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpath__to__pol__id.html">path_to_pol_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpath__storage.html">path_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">storage path buffers which cannot fit on ebpf stack per cpu is important to prevent concurrency issues  <a href="structpath__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae003a38311b8eb87254113b1c57a38f0" id="r_ae003a38311b8eb87254113b1c57a38f0"><td class="memItemLeft" align="right" valign="top"><a id="ae003a38311b8eb87254113b1c57a38f0" name="ae003a38311b8eb87254113b1c57a38f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FMODE_WRITE</b>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="separator:ae003a38311b8eb87254113b1c57a38f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a29a8315efd07a8542742e0c0cc389e0a" id="r_a29a8315efd07a8542742e0c0cc389e0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a29a8315efd07a8542742e0c0cc389e0a">seabee_bpf_map</a> (struct bpf_map *map, fmode_t fmode, int ret)</td></tr>
<tr class="memdesc:a29a8315efd07a8542742e0c0cc389e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks manipulation a protected map.  <br /></td></tr>
<tr class="separator:a29a8315efd07a8542742e0c0cc389e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0513d1676e6013f62974623e1523da" id="r_a5e0513d1676e6013f62974623e1523da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a5e0513d1676e6013f62974623e1523da">seabee_locked_down</a> (enum lockdown_reason what,)</td></tr>
<tr class="memdesc:a5e0513d1676e6013f62974623e1523da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the use of the bpf_write_user() helper.  <br /></td></tr>
<tr class="separator:a5e0513d1676e6013f62974623e1523da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0493f708b0f0ddf94b055afa38347f9" id="r_ae0493f708b0f0ddf94b055afa38347f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#ae0493f708b0f0ddf94b055afa38347f9">seabee_task_kill</a> (struct task_struct *p, struct kernel_siginfo *info, int sig, const struct cred *cred, int ret)</td></tr>
<tr class="memdesc:ae0493f708b0f0ddf94b055afa38347f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block unwanted signals to the seabee userspace process.  <br /></td></tr>
<tr class="separator:ae0493f708b0f0ddf94b055afa38347f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17afaf237b1083b2eb37cb8607c6bb3f" id="r_a17afaf237b1083b2eb37cb8607c6bb3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a17afaf237b1083b2eb37cb8607c6bb3f">seabee_file_open</a> (struct file *file,)</td></tr>
<tr class="memdesc:a17afaf237b1083b2eb37cb8607c6bb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">make protected files read-only.  <br /></td></tr>
<tr class="separator:a17afaf237b1083b2eb37cb8607c6bb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7f3d94e0b63c9c542cb3bd148a32ba" id="r_afd7f3d94e0b63c9c542cb3bd148a32ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#afd7f3d94e0b63c9c542cb3bd148a32ba">seabee_inode_permission</a> (struct inode *inode, int mask)</td></tr>
<tr class="memdesc:afd7f3d94e0b63c9c542cb3bd148a32ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">prevent writes to protected inodes  <br /></td></tr>
<tr class="separator:afd7f3d94e0b63c9c542cb3bd148a32ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822a366694e525af891bb9bf15a78b23" id="r_a822a366694e525af891bb9bf15a78b23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a822a366694e525af891bb9bf15a78b23">seabee_inode_unlink</a> (struct inode *dir, struct dentry *dentry)</td></tr>
<tr class="memdesc:a822a366694e525af891bb9bf15a78b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents unlinking/removing protected files or pins.  <br /></td></tr>
<tr class="separator:a822a366694e525af891bb9bf15a78b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a056af5cd6c297d113a683235b9651" id="r_a30a056af5cd6c297d113a683235b9651"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a30a056af5cd6c297d113a683235b9651">seabee_inode_rmdir</a> (struct inode *dir, struct dentry *dentry)</td></tr>
<tr class="memdesc:a30a056af5cd6c297d113a683235b9651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents unlinking/removing protected folders.  <br /></td></tr>
<tr class="separator:a30a056af5cd6c297d113a683235b9651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bc8ad102c8c67c5fd209add6b191ee" id="r_a98bc8ad102c8c67c5fd209add6b191ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a98bc8ad102c8c67c5fd209add6b191ee">seabee_inode_setattr</a> (struct dentry *dentry, struct iattr *attr)</td></tr>
<tr class="memdesc:a98bc8ad102c8c67c5fd209add6b191ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">prevents modification of attributes on protected inodes  <br /></td></tr>
<tr class="separator:a98bc8ad102c8c67c5fd209add6b191ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a2c09b96cdcc91f0dc4acafced3dd7" id="r_ab9a2c09b96cdcc91f0dc4acafced3dd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#ab9a2c09b96cdcc91f0dc4acafced3dd7">seabee_inode_setxattr</a> (struct user_namespace *mnt_userns, struct dentry *dentry, const char *name, const void *value, size_t size, int flags)</td></tr>
<tr class="memdesc:ab9a2c09b96cdcc91f0dc4acafced3dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">prevent modification of extended attributes on protected inodes  <br /></td></tr>
<tr class="separator:ab9a2c09b96cdcc91f0dc4acafced3dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b94607582fb50de92fb8bc133407c4a" id="r_a6b94607582fb50de92fb8bc133407c4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a6b94607582fb50de92fb8bc133407c4a">seabee_inode_rename</a> (struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, unsigned int flags)</td></tr>
<tr class="memdesc:a6b94607582fb50de92fb8bc133407c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">prevent rename of a protected inode  <br /></td></tr>
<tr class="separator:a6b94607582fb50de92fb8bc133407c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b9df20c0568dc8c64f602f63e14856" id="r_a81b9df20c0568dc8c64f602f63e14856"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a81b9df20c0568dc8c64f602f63e14856">seabee_sb_umount</a> (struct vfsmount *mnt, int flags, int ret)</td></tr>
<tr class="memdesc:a81b9df20c0568dc8c64f602f63e14856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent unmounting the BPF filesystem.  <br /></td></tr>
<tr class="separator:a81b9df20c0568dc8c64f602f63e14856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4c0b3cece29f53f28020c11e5310fc" id="r_afe4c0b3cece29f53f28020c11e5310fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#afe4c0b3cece29f53f28020c11e5310fc">seabee_kernel_module_request</a> (char *kmod_name,)</td></tr>
<tr class="memdesc:afe4c0b3cece29f53f28020c11e5310fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent a kernel module from being automatically loaded by the kernel.  <br /></td></tr>
<tr class="separator:afe4c0b3cece29f53f28020c11e5310fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485e0bd9e20eae669ea092248bf26ecf" id="r_a485e0bd9e20eae669ea092248bf26ecf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a485e0bd9e20eae669ea092248bf26ecf">seabee_kernel_read_file</a> (struct file *file, enum kernel_read_file_id id, bool contents)</td></tr>
<tr class="memdesc:a485e0bd9e20eae669ea092248bf26ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the loading of a kernel module via a file handle.  <br /></td></tr>
<tr class="separator:a485e0bd9e20eae669ea092248bf26ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256b85baf8c830a5ed40975c94943bdd" id="r_a256b85baf8c830a5ed40975c94943bdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a256b85baf8c830a5ed40975c94943bdd">seabee_kernel_load_data</a> (enum kernel_load_data_id id, bool contents)</td></tr>
<tr class="memdesc:a256b85baf8c830a5ed40975c94943bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the loading of a kernel module via a data blob.  <br /></td></tr>
<tr class="separator:a256b85baf8c830a5ed40975c94943bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28ea14e7ad0112bd28ca673105daf7e" id="r_ad28ea14e7ad0112bd28ca673105daf7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#ad28ea14e7ad0112bd28ca673105daf7e">seabee_ptrace_access_check</a> (struct task_struct *child, unsigned int mode, int ret)</td></tr>
<tr class="memdesc:ad28ea14e7ad0112bd28ca673105daf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks attempts to ptrace a protected process.  <br /></td></tr>
<tr class="separator:ad28ea14e7ad0112bd28ca673105daf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896edf055e965814fe057c78e6206c59" id="r_a896edf055e965814fe057c78e6206c59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a896edf055e965814fe057c78e6206c59">seabee_task_alloc</a> (struct task_struct *task, unsigned long clone_flags, int ret)</td></tr>
<tr class="memdesc:a896edf055e965814fe057c78e6206c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks attempts to fork() the seabee process.  <br /></td></tr>
<tr class="separator:a896edf055e965814fe057c78e6206c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b867df13b7a473049f1a0f3b7a2033" id="r_a85b867df13b7a473049f1a0f3b7a2033"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a85b867df13b7a473049f1a0f3b7a2033">seabee_label_sock</a> (struct socket *sock, struct sockaddr *address, int addrlen)</td></tr>
<tr class="memdesc:a85b867df13b7a473049f1a0f3b7a2033"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to label a socket on creation.  <br /></td></tr>
<tr class="separator:a85b867df13b7a473049f1a0f3b7a2033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7862e20a4d187c60d970fdf02fd84c55" id="r_a7862e20a4d187c60d970fdf02fd84c55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a7862e20a4d187c60d970fdf02fd84c55">seabeectl_auth</a> (struct sock *sock, struct sock *other, struct sock *newsk)</td></tr>
<tr class="memdesc:a7862e20a4d187c60d970fdf02fd84c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a process is allowed to connect to a socket.  <br /></td></tr>
<tr class="separator:a7862e20a4d187c60d970fdf02fd84c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9230263f1e385048936352e3412647bf" id="r_a9230263f1e385048936352e3412647bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a9230263f1e385048936352e3412647bf">seabee_label_process</a> (struct linux_binprm *bprm, int ret)</td></tr>
<tr class="memdesc:a9230263f1e385048936352e3412647bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label a process when it starts.  <br /></td></tr>
<tr class="separator:a9230263f1e385048936352e3412647bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd6be4f79d69edaf1cc0ff88f15503f" id="r_a0bd6be4f79d69edaf1cc0ff88f15503f"><td class="memItemLeft" align="right" valign="top"><a id="a0bd6be4f79d69edaf1cc0ff88f15503f" name="a0bd6be4f79d69edaf1cc0ff88f15503f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>seabee_label_child_process</b> (struct task_struct *child_task, unsigned long clone_flags)</td></tr>
<tr class="memdesc:a0bd6be4f79d69edaf1cc0ff88f15503f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label a child process with same policy id as its parent. <br /></td></tr>
<tr class="separator:a0bd6be4f79d69edaf1cc0ff88f15503f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641b53fae75f39ccce37bb0de0f731de" id="r_a641b53fae75f39ccce37bb0de0f731de"><td class="memItemLeft" align="right" valign="top"><a id="a641b53fae75f39ccce37bb0de0f731de" name="a641b53fae75f39ccce37bb0de0f731de"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>seabee_label_map</b> (struct bpf_map *map, int ret)</td></tr>
<tr class="memdesc:a641b53fae75f39ccce37bb0de0f731de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label a bpf map on creation using the same label as the process that created it. <br /></td></tr>
<tr class="separator:a641b53fae75f39ccce37bb0de0f731de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18317988a2eda364be8a3107e08d6c6c" id="r_a18317988a2eda364be8a3107e08d6c6c"><td class="memItemLeft" align="right" valign="top"><a id="a18317988a2eda364be8a3107e08d6c6c" name="a18317988a2eda364be8a3107e08d6c6c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>seabee_unlabel_map</b> (struct bpf_map *map, int ret)</td></tr>
<tr class="memdesc:a18317988a2eda364be8a3107e08d6c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlabel an eBPF map when it is freed. <br /></td></tr>
<tr class="separator:a18317988a2eda364be8a3107e08d6c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c18a6e95014436249584f5fb001fbb6" id="r_a7c18a6e95014436249584f5fb001fbb6"><td class="memItemLeft" align="right" valign="top"><a id="a7c18a6e95014436249584f5fb001fbb6" name="a7c18a6e95014436249584f5fb001fbb6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>seabee_start_pin</b> (int cmd, union bpf_attr *attr, unsigned int size, int ret)</td></tr>
<tr class="memdesc:a7c18a6e95014436249584f5fb001fbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to identify a bpf program is being pinned. <br /></td></tr>
<tr class="separator:a7c18a6e95014436249584f5fb001fbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3c66b2559a840e40aaf61b96844894" id="r_aeb3c66b2559a840e40aaf61b96844894"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#aeb3c66b2559a840e40aaf61b96844894">seabee_label_pin</a> (struct dentry *dentry, struct inode *inode)</td></tr>
<tr class="memdesc:aeb3c66b2559a840e40aaf61b96844894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label an inode associted with a bpf pin.  <br /></td></tr>
<tr class="separator:aeb3c66b2559a840e40aaf61b96844894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e6300b1425828b019affbe34e54639" id="r_aa3e6300b1425828b019affbe34e54639"><td class="memItemLeft" align="right" valign="top"><a id="aa3e6300b1425828b019affbe34e54639" name="aa3e6300b1425828b019affbe34e54639"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>seabee_stop_pin</b> (struct dentry *dentry, struct inode *inode)</td></tr>
<tr class="memdesc:aa3e6300b1425828b019affbe34e54639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to identify that a process has finished pinning. <br /></td></tr>
<tr class="separator:aa3e6300b1425828b019affbe34e54639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2469f2c043646301fa4510ea7c90c75c" id="r_a2469f2c043646301fa4510ea7c90c75c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a2469f2c043646301fa4510ea7c90c75c">seabee_label_inode_runtime</a> (struct dentry *dentry, struct inode *inode)</td></tr>
<tr class="memdesc:a2469f2c043646301fa4510ea7c90c75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label inodes created at runtime giving them the same label as the parent.  <br /></td></tr>
<tr class="separator:a2469f2c043646301fa4510ea7c90c75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a094e2d5d611f0260d7e08d3e03c4dafd" id="r_a094e2d5d611f0260d7e08d3e03c4dafd"><td class="memItemLeft" align="right" valign="top"><a id="a094e2d5d611f0260d7e08d3e03c4dafd" name="a094e2d5d611f0260d7e08d3e03c4dafd"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>LICENSE</b> [] = &quot;GPL&quot;</td></tr>
<tr class="memdesc:a094e2d5d611f0260d7e08d3e03c4dafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">License of the BPF program. <br /></td></tr>
<tr class="separator:a094e2d5d611f0260d7e08d3e03c4dafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5b3870f32ed99cf58fe41b09d15181" id="r_a9e5b3870f32ed99cf58fe41b09d15181"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#a9e5b3870f32ed99cf58fe41b09d15181">log_level</a></td></tr>
<tr class="memdesc:a9e5b3870f32ed99cf58fe41b09d15181"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of the logs to filter out.  <br /></td></tr>
<tr class="separator:a9e5b3870f32ed99cf58fe41b09d15181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6260542ad29c93bcc8f09d6a11f4e587" id="r_a6260542ad29c93bcc8f09d6a11f4e587"><td class="memItemLeft" align="right" valign="top"><a id="a6260542ad29c93bcc8f09d6a11f4e587" name="a6260542ad29c93bcc8f09d6a11f4e587"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><b>kmod_modification</b></td></tr>
<tr class="memdesc:a6260542ad29c93bcc8f09d6a11f4e587"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of access for kernel modules. <br /></td></tr>
<tr class="separator:a6260542ad29c93bcc8f09d6a11f4e587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae208ec30e868b98262cf15e4f4f88f9e" id="r_ae208ec30e868b98262cf15e4f4f88f9e"><td class="memItemLeft" align="right" valign="top"><a id="ae208ec30e868b98262cf15e4f4f88f9e" name="ae208ec30e868b98262cf15e4f4f88f9e"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><b>my_pid</b></td></tr>
<tr class="memdesc:ae208ec30e868b98262cf15e4f4f88f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The process id of the userspace that loads these programs. <br /></td></tr>
<tr class="separator:ae208ec30e868b98262cf15e4f4f88f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d2cefaf8097b3f9b8a363d261da3bd" id="r_ac9d2cefaf8097b3f9b8a363d261da3bd"><td class="memItemLeft" align="right" valign="top"><a id="ac9d2cefaf8097b3f9b8a363d261da3bd" name="ac9d2cefaf8097b3f9b8a363d261da3bd"></a>
u64&#160;</td><td class="memItemRight" valign="bottom"><b>bpf_dev_id</b></td></tr>
<tr class="memdesc:ac9d2cefaf8097b3f9b8a363d261da3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device id of the /sys/bpf mount point inode. <br /></td></tr>
<tr class="separator:ac9d2cefaf8097b3f9b8a363d261da3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccd1c4eb376a6a5f6401d616a68bd50" id="r_aeccd1c4eb376a6a5f6401d616a68bd50"><td class="memItemLeft" align="right" valign="top"><a id="aeccd1c4eb376a6a5f6401d616a68bd50" name="aeccd1c4eb376a6a5f6401d616a68bd50"></a>
u64&#160;</td><td class="memItemRight" valign="bottom"><b>sys_dev_id</b></td></tr>
<tr class="memdesc:aeccd1c4eb376a6a5f6401d616a68bd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device id of the /sys mount point inode. <br /></td></tr>
<tr class="separator:aeccd1c4eb376a6a5f6401d616a68bd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb760c538cb75e9aaa2b412afe58ce9" id="r_a1cb760c538cb75e9aaa2b412afe58ce9"><td class="memItemLeft" align="right" valign="top"><a id="a1cb760c538cb75e9aaa2b412afe58ce9" name="a1cb760c538cb75e9aaa2b412afe58ce9"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><b>my_binary_path</b> [<a class="el" href="constants_8h.html#ae688d728e1acdfe5988c7db45d6f0166">PATH_MAX</a>]</td></tr>
<tr class="memdesc:a1cb760c538cb75e9aaa2b412afe58ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The path of the seabee binary. u8 plays nicer with rust. <br /></td></tr>
<tr class="separator:a1cb760c538cb75e9aaa2b412afe58ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eca4835f7fc2823d9a0826997a38f22" id="r_a8eca4835f7fc2823d9a0826997a38f22"><td class="memItemLeft" align="right" valign="top"><a id="a8eca4835f7fc2823d9a0826997a38f22" name="a8eca4835f7fc2823d9a0826997a38f22"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><b>null_path</b> [<a class="el" href="constants_8h.html#ae688d728e1acdfe5988c7db45d6f0166">PATH_MAX</a>]</td></tr>
<tr class="memdesc:a8eca4835f7fc2823d9a0826997a38f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to null a buffer <br /></td></tr>
<tr class="separator:a8eca4835f7fc2823d9a0826997a38f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47d839b2119d334db696f6d365fc90f" id="r_aa47d839b2119d334db696f6d365fc90f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlog__ringbuf.html">log_ringbuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#aa47d839b2119d334db696f6d365fc90f">log_ringbuf</a></td></tr>
<tr class="memdesc:aa47d839b2119d334db696f6d365fc90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">eBPF Maps  <br /></td></tr>
<tr class="separator:aa47d839b2119d334db696f6d365fc90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf9bb9f0374c3d689bdbbf1fa50bef2" id="r_adaf9bb9f0374c3d689bdbbf1fa50bef2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structinode__storage.html">inode_storage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#adaf9bb9f0374c3d689bdbbf1fa50bef2">inode_storage</a></td></tr>
<tr class="memdesc:adaf9bb9f0374c3d689bdbbf1fa50bef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps and inode to a policy id  <br /></td></tr>
<tr class="separator:adaf9bb9f0374c3d689bdbbf1fa50bef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0556a1da33555a2a9b767da533a674" id="r_aec0556a1da33555a2a9b767da533a674"><td class="memItemLeft" align="right" valign="top"><a id="aec0556a1da33555a2a9b767da533a674" name="aec0556a1da33555a2a9b767da533a674"></a>
struct <a class="el" href="structpolicy__map.html">policy_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>policy_map</b></td></tr>
<tr class="memdesc:aec0556a1da33555a2a9b767da533a674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashmap from policy id to policy config. <br /></td></tr>
<tr class="separator:aec0556a1da33555a2a9b767da533a674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4848f79808fd9d1ccaa5cfecca26f64" id="r_aa4848f79808fd9d1ccaa5cfecca26f64"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtask__storage.html">task_storage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="seabee_8bpf_8c.html#aa4848f79808fd9d1ccaa5cfecca26f64">task_storage</a></td></tr>
<tr class="memdesc:aa4848f79808fd9d1ccaa5cfecca26f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps process pid to policy id  <br /></td></tr>
<tr class="separator:aa4848f79808fd9d1ccaa5cfecca26f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7dc065169aed1b6541cc68dd10be4b" id="r_acc7dc065169aed1b6541cc68dd10be4b"><td class="memItemLeft" align="right" valign="top"><a id="acc7dc065169aed1b6541cc68dd10be4b" name="acc7dc065169aed1b6541cc68dd10be4b"></a>
struct <a class="el" href="structsk__storage.html">sk_storage</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sk_storage</b></td></tr>
<tr class="memdesc:acc7dc065169aed1b6541cc68dd10be4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct sock to policy id <br /></td></tr>
<tr class="separator:acc7dc065169aed1b6541cc68dd10be4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da566d32339313171e0f49c17d96ee2" id="r_a6da566d32339313171e0f49c17d96ee2"><td class="memItemLeft" align="right" valign="top"><a id="a6da566d32339313171e0f49c17d96ee2" name="a6da566d32339313171e0f49c17d96ee2"></a>
struct <a class="el" href="structmap__to__pol__id.html">map_to_pol_id</a>&#160;</td><td class="memItemRight" valign="bottom"><b>map_to_pol_id</b></td></tr>
<tr class="memdesc:a6da566d32339313171e0f49c17d96ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a map id to a policy id <br /></td></tr>
<tr class="separator:a6da566d32339313171e0f49c17d96ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7327035a79233143a9901d4f0f6262e2" id="r_a7327035a79233143a9901d4f0f6262e2"><td class="memItemLeft" align="right" valign="top"><a id="a7327035a79233143a9901d4f0f6262e2" name="a7327035a79233143a9901d4f0f6262e2"></a>
struct <a class="el" href="structpath__to__pol__id.html">path_to_pol_id</a>&#160;</td><td class="memItemRight" valign="bottom"><b>path_to_pol_id</b></td></tr>
<tr class="memdesc:a7327035a79233143a9901d4f0f6262e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a filename to a policy id. <br /></td></tr>
<tr class="separator:a7327035a79233143a9901d4f0f6262e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443b441d347ce06759c65955d04ecf2d" id="r_a443b441d347ce06759c65955d04ecf2d"><td class="memItemLeft" align="right" valign="top"><a id="a443b441d347ce06759c65955d04ecf2d" name="a443b441d347ce06759c65955d04ecf2d"></a>
struct <a class="el" href="structpath__storage.html">path_storage</a>&#160;</td><td class="memItemRight" valign="bottom"><b>path_storage</b></td></tr>
<tr class="memdesc:a443b441d347ce06759c65955d04ecf2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">storage for paths <br /></td></tr>
<tr class="separator:a443b441d347ce06759c65955d04ecf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a29a8315efd07a8542742e0c0cc389e0a" name="a29a8315efd07a8542742e0c0cc389e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a8315efd07a8542742e0c0cc389e0a">&#9670;&#160;</a></span>seabee_bpf_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_bpf_map </td>
          <td>(</td>
          <td class="paramtype">struct bpf_map *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmode_t&#160;</td>
          <td class="paramname"><em>fmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks manipulation a protected map. </p>
<p>This is achieved by preventing BPF file descriptors from being created for protected maps.</p>
<p>A file descriptor for a map can be obtained via the commands:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>internal BPF map structure </td></tr>
    <tr><td class="paramname">fmode</td><td>file mode to open with (read / write / etc) </td></tr>
    <tr><td class="paramname">ret</td><td>return code from previous LSM hook</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a17afaf237b1083b2eb37cb8607c6bb3f" name="a17afaf237b1083b2eb37cb8607c6bb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17afaf237b1083b2eb37cb8607c6bb3f">&#9670;&#160;</a></span>seabee_file_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_file_open </td>
          <td>(</td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make protected files read-only. </p>
<p>This hook is called to check if a file is allowed to be accessed. Deny access to protected files by checking file-&gt;f_mode. This tells if the file is being opened for reading or writing. </p>

</div>
</div>
<a id="afd7f3d94e0b63c9c542cb3bd148a32ba" name="afd7f3d94e0b63c9c542cb3bd148a32ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7f3d94e0b63c9c542cb3bd148a32ba">&#9670;&#160;</a></span>seabee_inode_permission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_inode_permission </td>
          <td>(</td>
          <td class="paramtype">struct inode *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prevent writes to protected inodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>inode </td></tr>
    <tr><td class="paramname">mask</td><td>access mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b94607582fb50de92fb8bc133407c4a" name="a6b94607582fb50de92fb8bc133407c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b94607582fb50de92fb8bc133407c4a">&#9670;&#160;</a></span>seabee_inode_rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_inode_rename </td>
          <td>(</td>
          <td class="paramtype">struct inode *&#160;</td>
          <td class="paramname"><em>old_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct dentry *&#160;</td>
          <td class="paramname"><em>old_dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct inode *&#160;</td>
          <td class="paramname"><em>new_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct dentry *&#160;</td>
          <td class="paramname"><em>new_dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prevent rename of a protected inode </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_dentry</td><td>the old file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30a056af5cd6c297d113a683235b9651" name="a30a056af5cd6c297d113a683235b9651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a056af5cd6c297d113a683235b9651">&#9670;&#160;</a></span>seabee_inode_rmdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_inode_rmdir </td>
          <td>(</td>
          <td class="paramtype">struct inode *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct dentry *&#160;</td>
          <td class="paramname"><em>dentry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents unlinking/removing protected folders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>the parent directory </td></tr>
    <tr><td class="paramname">dentry</td><td>the directory to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a98bc8ad102c8c67c5fd209add6b191ee" name="a98bc8ad102c8c67c5fd209add6b191ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bc8ad102c8c67c5fd209add6b191ee">&#9670;&#160;</a></span>seabee_inode_setattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_inode_setattr </td>
          <td>(</td>
          <td class="paramtype">struct dentry *&#160;</td>
          <td class="paramname"><em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iattr *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prevents modification of attributes on protected inodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dentry</td><td>file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9a2c09b96cdcc91f0dc4acafced3dd7" name="ab9a2c09b96cdcc91f0dc4acafced3dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a2c09b96cdcc91f0dc4acafced3dd7">&#9670;&#160;</a></span>seabee_inode_setxattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_inode_setxattr </td>
          <td>(</td>
          <td class="paramtype">struct user_namespace *&#160;</td>
          <td class="paramname"><em>mnt_userns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct dentry *&#160;</td>
          <td class="paramname"><em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prevent modification of extended attributes on protected inodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dentry</td><td>file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a822a366694e525af891bb9bf15a78b23" name="a822a366694e525af891bb9bf15a78b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822a366694e525af891bb9bf15a78b23">&#9670;&#160;</a></span>seabee_inode_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_inode_unlink </td>
          <td>(</td>
          <td class="paramtype">struct inode *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct dentry *&#160;</td>
          <td class="paramname"><em>dentry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents unlinking/removing protected files or pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>the parent directory </td></tr>
    <tr><td class="paramname">dentry</td><td>the file being unlinked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a256b85baf8c830a5ed40975c94943bdd" name="a256b85baf8c830a5ed40975c94943bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256b85baf8c830a5ed40975c94943bdd">&#9670;&#160;</a></span>seabee_kernel_load_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_kernel_load_data </td>
          <td>(</td>
          <td class="paramtype">enum kernel_load_data_id&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>contents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the loading of a kernel module via a data blob. </p>
<p>lsm/kernel_load_data is invoked when userspace tries to load a data blob from its memory into the kernel, including but not limited to kernel modules loaded via init_module().</p>
<p>enum kernel_load_data_id is the same as __kernel_read_file_id defined in <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/kernel_read_file.h#L9">https://elixir.bootlin.com/linux/latest/source/include/linux/kernel_read_file.h#L9</a> It has several types including unknown, firmware, module, kexec-image, kexec-initramfs, security-policy, and x509-certificate. kernel-module seems most appropriate for our purposes, but the others should be taken into account later on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>defines what kind of data is being read. </td></tr>
    <tr><td class="paramname">contents</td><td>true if security_kernel_post_load_data() will be called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="afe4c0b3cece29f53f28020c11e5310fc" name="afe4c0b3cece29f53f28020c11e5310fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4c0b3cece29f53f28020c11e5310fc">&#9670;&#160;</a></span>seabee_kernel_module_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_kernel_module_request </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>kmod_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevent a kernel module from being automatically loaded by the kernel. </p>
<p>lsm/kernel_module_request is invoked when module auto-loading is triggered by some attempt to access kernel functionality implemented by a module. It is used internally by the kernel to check if loading a module is allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kmod_name</td><td>the name of ther kernel module to be loaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a485e0bd9e20eae669ea092248bf26ecf" name="a485e0bd9e20eae669ea092248bf26ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485e0bd9e20eae669ea092248bf26ecf">&#9670;&#160;</a></span>seabee_kernel_read_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_kernel_read_file </td>
          <td>(</td>
          <td class="paramtype">struct file *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum kernel_read_file_id&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>contents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the loading of a kernel module via a file handle. </p>
<p>lsm/kernel_read_file is invoked when the kernel is about to directly read from a file or the file system specified by userspace for some purpose including but not limited to kernel modules laoded via finit_module()</p>
<p>enum kernel_load_data_id is the same as __kernel_read_file_id defined in <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/kernel_read_file.h#L9">https://elixir.bootlin.com/linux/latest/source/include/linux/kernel_read_file.h#L9</a> It has several types including unknown, firmware, module, kexec-image, kexec-initramfs, security-policy, and x509-certificate. kernel-module seems most appropriate for our purposes, but the others should be taken into account later on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the file from which to read </td></tr>
    <tr><td class="paramname">id</td><td>identifies the type of data that is being read </td></tr>
    <tr><td class="paramname">contents</td><td>true if security_post_read_file() will be called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a2469f2c043646301fa4510ea7c90c75c" name="a2469f2c043646301fa4510ea7c90c75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2469f2c043646301fa4510ea7c90c75c">&#9670;&#160;</a></span>seabee_label_inode_runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_label_inode_runtime </td>
          <td>(</td>
          <td class="paramtype">struct dentry *&#160;</td>
          <td class="paramname"><em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct inode *&#160;</td>
          <td class="paramname"><em>inode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Label inodes created at runtime giving them the same label as the parent. </p>
<p>security_d_instantiate is called whenever a dentry is first associated with an inode. That could be on creation or when it is first looked up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dentry</td><td>dentry </td></tr>
    <tr><td class="paramname">inode</td><td>inode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb3c66b2559a840e40aaf61b96844894" name="aeb3c66b2559a840e40aaf61b96844894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3c66b2559a840e40aaf61b96844894">&#9670;&#160;</a></span>seabee_label_pin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_label_pin </td>
          <td>(</td>
          <td class="paramtype">struct dentry *&#160;</td>
          <td class="paramname"><em>dentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct inode *&#160;</td>
          <td class="paramname"><em>inode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Label an inode associted with a bpf pin. </p>
<p>This hook is called when a dentry becomes associted with an inode. </p>

</div>
</div>
<a id="a9230263f1e385048936352e3412647bf" name="a9230263f1e385048936352e3412647bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9230263f1e385048936352e3412647bf">&#9670;&#160;</a></span>seabee_label_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_label_process </td>
          <td>(</td>
          <td class="paramtype">struct linux_binprm *&#160;</td>
          <td class="paramname"><em>bprm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Label a process when it starts. </p>
<p>This uses the <a class="el" href="structpath__to__pol__id.html">path_to_pol_id</a> map and the linux_binprm structure to attach a label to a task based on the path of the executable that started the task. This hook can be called multiple times during an execve, for example, if executing a script.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bprm</td><td>holds information about a binary that is going to be executed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> since this check is just for labeling and not for enforcement </dd></dl>

</div>
</div>
<a id="a85b867df13b7a473049f1a0f3b7a2033" name="a85b867df13b7a473049f1a0f3b7a2033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b867df13b7a473049f1a0f3b7a2033">&#9670;&#160;</a></span>seabee_label_sock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_label_sock </td>
          <td>(</td>
          <td class="paramtype">struct socket *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>used to label a socket on creation. </p>
<p>This will only label sockets created by the SeaBee userspace. Specifically this is used to control access to SeaBee's listening socket to ensure only seabeectl can connect to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>the socket being bound </td></tr>
    <tr><td class="paramname">address</td><td>requested bind address </td></tr>
    <tr><td class="paramname">addrlen</td><td>length of address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> to allow access </dd></dl>

</div>
</div>
<a id="a5e0513d1676e6013f62974623e1523da" name="a5e0513d1676e6013f62974623e1523da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0513d1676e6013f62974623e1523da">&#9670;&#160;</a></span>seabee_locked_down()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_locked_down </td>
          <td>(</td>
          <td class="paramtype">enum lockdown_reason&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the use of the bpf_write_user() helper. </p>
<p>This helper function is dangerous and it is better to disable it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>why the lockdown hook is firing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code>man 7 kernel_lockdown</code> </dd></dl>

</div>
</div>
<a id="ad28ea14e7ad0112bd28ca673105daf7e" name="ad28ea14e7ad0112bd28ca673105daf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28ea14e7ad0112bd28ca673105daf7e">&#9670;&#160;</a></span>seabee_ptrace_access_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_ptrace_access_check </td>
          <td>(</td>
          <td class="paramtype">struct task_struct *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks attempts to ptrace a protected process. </p>
<p>This hook is called by a "tracer" process that is trying to use ptrace on a "tracee" process. In this case, the "child" argument.</p>
<p>note: there is also an lsm/ptrace_traceme hook. This hook is not checked because it is only invoked by the child process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the process that is going to be traced (tracee) </td></tr>
    <tr><td class="paramname">mode</td><td>PTRACE_MODE flags, see linux/ptrace.h </td></tr>
    <tr><td class="paramname">ret</td><td>the return code of the previous LSM hook</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a81b9df20c0568dc8c64f602f63e14856" name="a81b9df20c0568dc8c64f602f63e14856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b9df20c0568dc8c64f602f63e14856">&#9670;&#160;</a></span>seabee_sb_umount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_sb_umount </td>
          <td>(</td>
          <td class="paramtype">struct vfsmount *&#160;</td>
          <td class="paramname"><em>mnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevent unmounting the BPF filesystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mnt</td><td>mounted filesystem </td></tr>
    <tr><td class="paramname">flags</td><td>unmount flags </td></tr>
    <tr><td class="paramname">ret</td><td>the return code of the previous LSM hook</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a896edf055e965814fe057c78e6206c59" name="a896edf055e965814fe057c78e6206c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896edf055e965814fe057c78e6206c59">&#9670;&#160;</a></span>seabee_task_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_task_alloc </td>
          <td>(</td>
          <td class="paramtype">struct task_struct *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>clone_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks attempts to fork() the seabee process. </p>
<p>A fork() / clone() of the seabee process will inherit all of the memory and file-descriptors of the parent process. This would allow the child process to unload the BPF program or alter the map contents. This is more of a safety-net than anything.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the process that is going to be forked </td></tr>
    <tr><td class="paramname">clone_flags</td><td>flags from struct kernel_clone_args </td></tr>
    <tr><td class="paramname">ret</td><td>the return code of the previous LSM hook</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="ae0493f708b0f0ddf94b055afa38347f9" name="ae0493f708b0f0ddf94b055afa38347f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0493f708b0f0ddf94b055afa38347f9">&#9670;&#160;</a></span>seabee_task_kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_task_kill </td>
          <td>(</td>
          <td class="paramtype">struct task_struct *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct kernel_siginfo *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct cred *&#160;</td>
          <td class="paramname"><em>cred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block unwanted signals to the seabee userspace process. </p>
<p>Deny any outside userspace signal that will stop our corresponding userspace process almost every signal will kill our process, we choose to enumerate (and allow) those which do not stop our process. Signals that originate from the kernel may not be caught because they may use a different code path that does not include this lsm hook. These signals include the <code><a class="el" href="seabee__utils_8h.html#ac328e551bde3d39b6d7b8cc9e048d941">ZERO</a></code> signal and any signal specified in the <code><a class="el" href="">signal_allow_mask</a></code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>target process </td></tr>
    <tr><td class="paramname">info</td><td>signal info, can also be NULL or 1 </td></tr>
    <tr><td class="paramname">sig</td><td>signal value </td></tr>
    <tr><td class="paramname">cred</td><td>credentials of sender, may be NULL </td></tr>
    <tr><td class="paramname">ret</td><td>the return code of the previous LSM hook</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code></dd></dl>
<dl class="section see"><dt>See also</dt><dd>signal numbering and default actions: <code>man signal</code> </dd></dl>

</div>
</div>
<a id="a7862e20a4d187c60d970fdf02fd84c55" name="a7862e20a4d187c60d970fdf02fd84c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7862e20a4d187c60d970fdf02fd84c55">&#9670;&#160;</a></span>seabeectl_auth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabeectl_auth </td>
          <td>(</td>
          <td class="paramtype">struct sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sock *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sock *&#160;</td>
          <td class="paramname"><em>newsk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if a process is allowed to connect to a socket. </p>
<p>This is used to enforce that only seabeectl is allowed to connect to the listening socket of SeaBee in order to receive commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>originating sock </td></tr>
    <tr><td class="paramname">other</td><td>peer sock </td></tr>
    <tr><td class="paramname">newsk</td><td>new sock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> to allow access </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="adaf9bb9f0374c3d689bdbbf1fa50bef2" name="adaf9bb9f0374c3d689bdbbf1fa50bef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf9bb9f0374c3d689bdbbf1fa50bef2">&#9670;&#160;</a></span>inode_storage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structinode__storage.html">inode_storage</a> <a class="el" href="structinode__storage.html">inode_storage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maps and inode to a policy id </p>
<p>local storage for inodes </p>

</div>
</div>
<a id="a9e5b3870f32ed99cf58fe41b09d15181" name="a9e5b3870f32ed99cf58fe41b09d15181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5b3870f32ed99cf58fe41b09d15181">&#9670;&#160;</a></span>log_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 log_level</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The level of the logs to filter out. </p>
<p>Defined in each .bpf.c file. Specifies which logs to output to the ringbuf. </p>

</div>
</div>
<a id="aa47d839b2119d334db696f6d365fc90f" name="aa47d839b2119d334db696f6d365fc90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47d839b2119d334db696f6d365fc90f">&#9670;&#160;</a></span>log_ringbuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlog__ringbuf.html">log_ringbuf</a> <a class="el" href="structlog__ringbuf.html">log_ringbuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>eBPF Maps </p>
<p>Defined in each .bpf.c file. Specifies the ringbuf map to output logs to.</p>
<p>logs data back to userspace </p>

</div>
</div>
<a id="aa4848f79808fd9d1ccaa5cfecca26f64" name="aa4848f79808fd9d1ccaa5cfecca26f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4848f79808fd9d1ccaa5cfecca26f64">&#9670;&#160;</a></span>task_storage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtask__storage.html">task_storage</a> <a class="el" href="structtask__storage.html">task_storage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maps process pid to policy id </p>
<p>local storage for tasks </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
